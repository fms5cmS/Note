
计算机的物理内存即内存条。

计算机的主存由多个连续的单元组成，每个单元称为一个字节，每个字节有一个唯一的物理地址（Physical Address，PA），地址编码从 0 开始，

# 局部性原理

绝大多数程序的运行过程中，当前指令大概率都会引用最近访问过的数据。即程序的数据访问会表现出明显的倾向性，这种倾向性称之为局部性原理 (Principle of locality)。

- 时间局部性，被访问过一次的内存位置很可能在不远的将来会被再次访问；
- 空间局部性，如果一个内存位置被引用过，那么它邻近的位置在不远的将来也有很大概率会被访问。

基于局部性原理，可以推论：无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的！所以，CPU 为每个进程只需要保留很少的物理内存就可以保证进程的正常执行了。

# 虚拟内存

- 直接操作物理内存
  - 需要知道每个变量的位置安排在哪里；
  - 要注意和当前进程同时工作的进程不能共用同一个地址，否则会造成地址冲突
- 操作虚拟内存
  - 独占所有内存，任意使用
  - 为变量和函数分配地址的话，交给链接器自动安排即可

任何虚拟内存最终都要映射到物理内存。CPU 充分利用程序局部性原理，提出了虚拟内存和物理内存的映射（Mapping）机制！！这种映射关系是以页为单位的，每个进程的虚拟内存页都被映射到物理内存页上。

1. 虽然虚拟内存提供了很大空间，但进程启动后，这些空间并不是全部都能使用的。开发者在对这块内存进行读写市，才会使用 malloc 等分配内存的接口真正为它分配物理内存；
2. 虚拟内存中连续的页面在物理内存中不必连续，只要维护好虚拟内存页到物理内存页的映射关系即可，而这个映射关系也是 OS 通过页表自动维护的。

注：虚拟地址空间通常与机器字宽有关，如 32 位机器上指向内存的指针是 32 位的，所以它的虚拟地址空间为 $2^{32}=4G$；64 位机器上指向内存的地址是 64 位，但在 64 位系统中只使用了低 48 位，所以其虚拟地址空间为 $2^{48}=256T$。

# 页表&页目录表

虚拟内存到物理内存的映射是由 CPU 的 MMU（Memory Management Unit，内存管理单元）自动完成的，但它依赖于 OS 设置的页表。

页表的本质是 PTE（Page Table Entry，页表项）数组。每个虚拟内存页和物理内存页的映射是通过 PTE 实现的，每个虚拟内存页对应一个 PTE，而每个 PTE 又记录了对应的物理内存页的起始地址。

1024 个 PTE（每个 PTE 占 4 字节） 组成一张页表，这样，一张页表本身占的大小就是 4K（正好一个物理内存页），而一张页表可以支持的物理内存空间大小为 $1024*4k=4MB$

> 每个物理内存页的大小也是 4K

为了编码更多地址，必须使用更多页表，所以，为了管理这些页表，又引入了页目录表。

页目录表中的每一项是 PDE Page Directory Entry, 页目录项)，每个 PDE 都对应一个页表，它记录了页表开始处的物理地址，这就是多级页表结构！

现代的 64 位处理器上，为了编码更大的空间，还存在更多级的页表

# CPU 怎么找到真实地址？

CPU 通过虚拟地址找到物理地址需要大概四个步骤（以 32 位操作系统为例）：

- 1.确定页目录基址
  - 每个 CPU 都有一个页目录基址寄存器，最高级页表的基地址就存在这个寄存器中，每次计算物理地址时，MMU 都会从里面取出页目录所在的物理地址；
- 2.定位 PDE
  - PDE 地址 = 页目录基址 + (虚拟地址的高 10 位 * 4)
  - 一个 PDE 是 4 字节，1024 个 PDE 占据 4096 字节，正好组成一页，而 1024 个 PDE 需要 10 位编码
- 3.定位 PTE
  - CPU 通过 PDE 找到页表的位置，PTE 地址 = 页表基址 + (虚拟地址中间 10 位 * 4)
- 4.确定真是的物理地址
  - PTE 中记录着物理地址
  - 虚拟地址的低 12 位刚好可以对一页内所有字节编码，所以用低 12 位代表页内偏移，计算公式是 物理页地址 + 低 12 位

在 64 位操作系统上，使用了 48 位的虚拟地址，所以需要使用 4 级页表，定位过程也变成了 5 步。
