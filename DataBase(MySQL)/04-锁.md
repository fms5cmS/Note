根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

# 全局锁

全局锁对整个数据库实例加锁。应用场景：**做全库逻辑备份**。

```sql
-- 加全局读锁
flush tables with read lock;
-- 释放锁
unlock tables;
```

让整库只读，很危险：

- 在主库备份，则备份期间都不能执行更新，业务基本上就得停摆；
- 在从库备份，备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用 `-single-transaction` 参数，导数据前会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这一过程中数据是可以增长更新的。

注：可重复读隔离级别下开启一个事务就可以拿到一致性视图。

使用 mysqldump 的前提是存储引擎支持这个隔离级别。对于 MyISAM 这种不支持事务的引擎，如果备份中有更新，总是能取到最新数据，就会破坏备份的一致性，所以需要加全局读锁。

# 表级锁

MySQL 中表级锁有两种：表锁、元数据锁（MDL）。

- 表锁，锁粒度大。一般是在数据库引擎不支持行锁的时候才会被用到

```sql
-- 给表加读锁或写锁
LOCK TABLE 表1 READ/WRITE, 表2 READ/WRITE ...
```

可以用 `unlock tables` 主动释放锁，也可以在客户端断开时自动释放。

| 加读锁             | 被锁的表                                                   | 其他表         |
| ------------------ | ---------------------------------------------------------- | -------------- |
| 执行上锁操作的会话 | 只能查询，不能做其他操作                                   | 不能做任何操作 |
| 其他会话           | 只能查询，其他操作会发生**阻塞**，等待锁被释放才会继续执行 | 可执行任何操作 |

| 加写锁             | 被锁的表                                   | 其它表         |
| ------------------ | ------------------------------------------ | -------------- |
| 执行上锁操作的会话 | 可执行任何操作                             | 不能做任何操作 |
| 其他会话           | 任何操作都被阻塞，等待锁被释放才会继续执行 | 可执行任何操作 |

- MDL（metadata lock），用于保证读写的正确性

**不需要显式使用，访问表时会被自动加上**。

对表增删改查时，加 MDL 读锁；对表结构变更时，加 MDL 写锁。

# 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，会影响到业务并发度。InnoDB 是支持行锁的。

事务一：

```sql
begin;
update t set k=k+1 where id=1;
update t set k=k+1 where id=2;
commit;
```

事务二：

```sql
begin;
update t set k=k+2 where id=1;
commit;
```

事务一持有两条记录的行锁，都是在 commit 时才释放，所以事务二的 update 语句会阻塞，直到事务一 commit 后才继续执行。

**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。**

所以，如果事务中需要锁多行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

# 死锁与死锁检测

当出现死锁后，通常有两种策略：

- 一：直接进入等待，直到超时
  - 超时时间可以通过 `innodb_lock_wait_timeout` 设置，默认 50s
- 二：发起死锁检测，发现死锁后，主动回滚死锁链中的某个事务，让其他事务得以继续执行
  - `innodb_dealock_detect` 设置为 on 表示开启这个逻辑，默认为 on

通常采用第二种策略，即主动死锁检测。尽管发生死锁时可以快速发现并处理，但这是有代价的。

每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。这是一个 O(N) 操作。

**热点行的更新会导致性能问题**：同时更新同一行的并发线程很多，就会消耗大量 CPU 资源用于检测。就会看到 CPU 利用率很高，但每秒执行不了几个事务。

如何让解决这一问题呢？

- 方法一：如果确保该业务不会出现死锁，可以临时关掉死锁检测。有一定的风险：
  - 关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。
  - 注：业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。
- 方法二：控制并发度
  - 不太可行，因为客户端很多，即使每个客户端并发线程很少，到了服务端并发数也会很大
- 方法三：从设计上优化，通过将一行改成逻辑上的多行来减少锁冲突
  - 如将账户放在多条记录上，账户总额等于多条记录的值的综合
  - 这样每次对账户金额操作时，随机选择其中一条记录来操作，就可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗
  - 余额减少时，如退票逻辑，还需要考虑当部分行记录为 0 时的特殊处理















