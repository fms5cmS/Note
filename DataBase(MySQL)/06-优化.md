![MySQL查询过程](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmDUkTYvddaNFvKMDupoF5MHNABHv3HIu0Gqe2xiazrOiatw3ajCGsVxMKtoB7eQyryxjOHW3lZrFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

数据库的优化：硬件、系统配置、数据库表结构、SQL 及索引。

# 优化工具

这一部分参照：[MySQL 高性能优化实战总结](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247486364&idx=1&sn=e40c7faa59bc177ea2083f7b03cf876d&chksm=fa49742dcd3efd3b9d986beb80ef283bcf5577a32fbcbd2534dfd28db0f7744dce87e60fe208&mpshare=1&scene=23&srcid=0314CsdaHPp8ThQn3BThxgm3#rd)，这里仅记录了数据库方面的内容。

## 数据库层面

检查问题常用工具：

```shell
msyqladmin                                 # mysql客户端，可进行管理操作
mysqlshow                                  # 功能强大的查看shell命令
show [SESSION | GLOBAL] variables          # 查看数据库参数信息
SHOW [SESSION | GLOBAL] STATUS             # 查看数据库的状态信息
information_schema                         # 获取元数据的方法
SHOW ENGINE INNODB STATUS                  # Innodb引擎的所有状态
SHOW PROCESSLIST                           # 查看当前所有连接session状态
explain                                    # 获取查询语句的执行计划
show index                                 # 查看表的索引信息
slow-log                                   # 记录慢查询语句
mysqldumpslow                              # 分析slowlog文件的
```

不常用但好用的工具：

```shell
zabbix                  # 监控主机、系统、数据库（部署zabbix监控平台）
pt-query-digest         # 分析慢日志
mysqlslap               # 分析慢日志
sysbench                # 压力测试工具
mysql profiling         # 统计数据库整体状态工具
Performance Schema      # mysql性能状态统计的数据
workbench               # 管理、备份、监控、分析、优化工具（比较费资源）
```

Zabbix 参照：http://www.cnblogs.com/clsn/p/7885990.html

### 问题解决思路

应急调优：突然的业务办理卡顿，无法进行正常的业务处理！需要立马解决的场景！

1. `show processlist;`
2. `explain SQL语句;`、`show index from 表;`
3. 通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题
4. `show status like '%lock%';` 查询锁状态
5. `kill SESSION_ID;` 杀掉有问题的 session

常规调优：针对业务周期性的卡顿，例如在每天 10-11 点业务特别慢，但是还能够使用，过了这段时间就好了。

1. 查看 slowlog，分析 slowlog，分析出查询慢的语句；
2. 按照一定优先级，进行一个一个的排查所有慢语句；
3. 分析 top sql，进行 explain 调试，查看语句执行时间；
4. 调整索引或语句本身。

# 数据库优化

这里参考[MySQL 优化指南](https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247485356&idx=1&sn=7e42b057e1985e26545f59ea092d822d&chksm=fbb28e52ccc50744acc91baad5ec0cf1516a6508445cafda0137a70acf62b567be828e066ace&mpshare=1&scene=23&srcid=0315VQjK62fLQVoRKoE8JkCd#rd)

## 单表优化

除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度。一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的，而事实上很多时候 MySQL 单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量。

- 字段设计：
  
  - 尽量使用 TINYINT、SMALLINT、MEDIUM_INT 作为整数类型而非 INT，如果非负则加上 UNSIGNED；
  - VARCHAR 的长度只分配真正需要的空间；
  - 使用枚举或整数代替字符串类型；
  - 尽量使用 TIMESTAMP 而非 DATETIME；
  - 单表不要有太多字段，建议在 20 以内；
  - 避免使用 NULL 字段，很难查询优化且占用额外索引空间；
  - 用整型来存 IP。

- 索引：
  
  - 根据查询有针对性的创建索引，考虑在 WHERE 和 ORDER BY 命令上涉及的列建立索引，可根据 EXPLAIN 来查看是否用了索引还是全表扫描；
  - 尽量避免在 WHERE 子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描；
  - 值分布很稀少的字段不适合建索引，例如“性别”这种只有两三个值的字段；
  - 字符字段只建前缀索引；
  - 字符字段最好不要做主键；
  - 不用外键，由程序保证约束；
  - 尽量不用 UNIQUE，由程序保证约束；
  - 使用多列索引时注意顺序和查询条件保持一致，同时删除不必要的单列索引。

- 查询 SQL：
  
  - 可通过开启慢查询日志来找出较慢的 SQL；
  - 不做列运算：`SELECT id WHERE age + 1 = 10`，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边；
  - sql 语句尽可能简单：一条 sql 只能在一个 cpu 运算；大语句拆小语句，减少锁时间；一条大 sql 可以堵死整个库；
  - 不用`SELECT *`；
  - OR 改写成 IN：OR 的效率是 n 级别，IN 的效率是 log(n)级别，IN 的个数建议控制在 200 以内；
  - 不用函数和触发器，在应用程序实现；
  - 避免`%xxx`式查询；
  - 少用 JOIN；
  - 使用同类型进行比较，比如用'123'和'123'比，123 和 123 比；
  - 尽量避免在 WHERE 子句中使用`!=`或`<>`操作符，否则将引擎放弃使用索引而进行全表扫描；
  - 对于连续数值，使用 BETWEEN 不用 IN：`SELECT id FROM t WHERE num BETWEEN 1 AND 5`；
  - 列表数据不要拿全表，要使用 LIMIT 来分页，每页数量也不要太大。

- 引擎：广泛使用的是 MyISAM 和 InnoDB 两种引擎。MyISAM 适合 SELECT 密集型的表，而 InnoDB 适合 INSERT 和 UPDATE 密集型的表
  
  - MyISAM：MySQL 5.1 及之前版本的默认引擎
    - 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁；
    - 不支持事务；
    - 不支持外键；
    - 不支持崩溃后的安全恢复；
    - 在表有读取查询的同时，支持往表中插入新纪录；
    - 支持 BLOB 和 TEXT 的前 500 个字符索引，支持全文索引；
    - 支持延迟更新索引，极大提升写入性能；
    - 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用。
  - InnoDB：MySQL 5.5 后的默认引擎
    - 支持行锁，采用 MVCC 来支持高并发；
    - 支持事务；
    - 支持外键；
    - 支持崩溃后的安全恢复；
    - 不支持全文索引。

## 表分区

MySQL 在 5.1 版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对 SQL 层来说是一个完全封装底层的黑盒子。MySQL 实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。

用户的 SQL 语句是需要针对分区表做优化，SQL 条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过`EXPLAIN PARTITIONS`来查看某条 SQL 语句会落在那些分区上，从而进行 SQL 优化。

- 分区的优点：
  - 可以让单表存储更多的数据；
  - 分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据，另外，还可以对一个独立分区进行优化、检查、修复等操作；
  - 部分查询能够从查询条件确定只落在少数分区上，速度会很快；
  - 分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备；
  - 可以使用分区表赖避免某些特殊瓶颈，例如 InnoDB 单个索引的互斥访问、ext3 文件系统的 inode 锁竞争；
  - 可以备份和恢复单个分区。
- 分区的缺点：
  - 一个表最多只能有 1024 个分区；
  - 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来；
  - 分区表无法使用外键约束；
  - NULL 值会使分区过滤无效；
  - 所有分区必须使用相同的存储引擎。
- 分区类型：
  - **RANGE 分区：**基于属于一个给定连续区间的列值，把多行分配给分区。
  - **LIST 分区：**类似于按 RANGE 分区，区别在于 LIST 分区是基于列值匹配一个离散值集合中的某个值来进行选择。
  - **HASH 分区：**基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含 MySQL 中有效的、产生非负整数值的任何表达式。
  - **KEY 分区：**类似于按 HASH 分区，区别在于 KEY 分区只支持计算一列或多列，且 MySQL 服务器提供其自身的哈希函数。必须有一列或多列包含整数值。

## 垂直拆分

垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。

垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。

- 优点：
  - 可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少 I/O 次数(每次查询时读取的 Block 就少)；
  - 可以达到最大化利用 Cache 的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起；
  - 数据维护简单。
- 缺点：
  - 主键出现冗余，需要管理冗余列；
  - 会引起表连接 JOIN 操作（增加 CPU 开销）可以通过在业务服务器上进行 join 来减少数据库压力；
  - 依然存在单表数据量过大的问题（需要水平拆分）。
  - 事务处理复杂。

## 水平拆分

水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的 MySQL 表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表。

库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻 MySQL 服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的 IO、CPU、网络，这个就要通过分库来解决。

实际情况中往往会是垂直拆分和水平拆分的结合。

- 优点：
  
  - 不存在单库大数据和高并发的性能瓶颈；
  - 应用端改造较少；
  - 提高了系统的稳定性和负载能力。

- 缺点：
  
  - 分片事务一致性难以解决；
  - 跨节点 Join 性能差，逻辑复杂；
  - 数据多次扩展难度跟维护量极大。

- 分片的原则：
  
  - 能不分就不分，参考单表优化；
  - 分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量；
  - 分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性 Hash 分片，这几种分片都有利于扩容；
  - 尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题；
  - 查询条件尽量优化，尽量避免 Select \* 的方式，大量数据结果集下，会消耗大量带宽和 CPU 资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引；
  - 通过数据冗余和表分区赖降低跨库 Join 的可能。
