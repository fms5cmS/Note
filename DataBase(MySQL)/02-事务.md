事务（transaction）特点：原子性是基础，隔离性是手段，一致性是约束条件，持久性是目的！

- Atomicity（原子性）：一个事务内的所有操作是一个整体，要么全部成功，要么全失败；
- Consistency（一致性）：事务提交或回滚后，数据库的完整性约束不能被破坏；
- Isolation（隔离性）：一个事务在提交之前，对其他事务都是不可见的；
- Durability（持久性）：事务提交之后对数据的修改是持久性的

# 事务并发

当同时运行的多个事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，会导致并发问题：

- 脏读：读到了其他事务还没有提交的数据（该数据被修改了）
  - 事务 T1 读取了已被 T2 更新但还未提交的字段，之后，若 T2 回滚，T1 读取的内容就是无效的
- 不可重复读：对某数据进行读取，发现**两次读取的结果不同**
  - 事务 T1 读取了一个字段，然后 T2 修改/删除了该字段，之后，T1 再次读取该字段，值就不同了
  - 重点在 UPDATE 和 DELETE
- 幻读：读到了其他事务**新增**的数据
  - 有事务 T1 读取了一个字段，然后 T2 在该表中插入一些新的行，之后，如果 T1 再次读取同一个表就会多出几行
  - 重点在 INSERT

脏读要一定避免！

# 事务隔离

多个事务同时执行时，由于隔离性的问题，可能出现脏读、不可重复读、幻读的问题。为了解决这些问题，就有了隔离级别，从低到高：（实现上，数据库中会创建一个视图，访问时以视图的逻辑结果为准。）

- 读未提交：允许事务读取未被其他事务提交的变更
  - 直接返回记录上的最新值，没有视图；
- 读已提交：只允许事务读取已被其他事务提交的变更
  - 该视图在每个 SQL 开始执行时创建
- 可重复读：一个事务执行过程中看到的数据总是与该事务启动时看到的数据一致
  - 该视图在事务启动时创建，整个事务存在期间都用这个视图
  - 在这个事务持续期间，禁止其他事务对这个字段进行更新
- 串行化：确保事务可以从一个表中读取相同的行。
  - 直接用加锁方式避免并行访问，性能很低

| 隔离级别（✓ 表示会发生该问题） | 脏读 | 不可重复读 | 幻读 |
| :----------------------------: | :--: | :--------: | :--: |
|  读未提交（Read Uncommitted)   |  ✓   |     ✓      |  ✓   |
|    读已提交(Read Committed)    |  ×   |     ✓      |  ✓   |
|   可重复读（Repeatable Read)   |  ×   |     ×      |  ✓   |
| 串行（序列）化（serializable)  |  ×   |     ×      |  ×   |

MySQL 支持 4 种事务隔离级别，默认的事务隔离级别是 `Repeatable Read`。 可以直接在 MySQL 中修改隔离级别，而不用在程序中修改。

Oracle 仅支持 2 种事务隔离级别：`Read committed`、`serializable`。默认的事务隔离级别是`Read committed`。

```sql
-- 查看当前连接的隔离级别
SELECT @@TX_ISOLATION;
-- 设置隔离级别
SET SESSION|GLOBAL TRANSACTION ISOLATION LEVEL 隔离级别;
```



# 事务隔离的实现

两种启动事务的方式：

- `begin`与`start transaction` 命令
  - 并不是一个事务的起点，只有在执行到第一个操作 InnoDB 表的语句时，事务才真正启动了
  - 一致性视图是在执行第一个快照语句时创建的
- `start transaction with consistent snapshot` 命令
  - 会立刻启动一个事务
  - 一致性视图是在执行该命令时创建的

在 MySQL 中，有两个视图的概念：

- view，用查询语句定义的虚拟表
- InnoDB 在实现 MVCC 时用的**一致性读视图（consistent read view）**，用于支持读已提交和可重复读的隔离级别的实现。
  - 同一条记录在系统中可以存在多个版本，这就是数据库的**多版本并发控制（MVCC）**
  - 一致性读视图没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

在 InnoDB 中，每个事务有一个唯一的事务 ID（transaction id），它是在事务开始时向 InnoDB 的事务系统申请的，按申请顺序严格递增。

数据表中的一行记录，可能有多个版本，每次事务更新数据时，会生成一个新的数据版本，并将 transaction id 赋值给这个数据版本的 row_trx_id，用于记录谁更新到当前版本的；

同时，每条记录在更新时会记录一条回滚操作，生成 undo log（回滚日志）；

不同的数据版本并不是物理存在的，而是每次需要时根据当前版本和 undo log 计算出来的。

## 快照

在可重复读隔离级别下，事务启动时会得到一个基于整库的快照。

Q：如果一个库 100G，那么启动一个事务就要拷贝 100G？

A：并非这样。

**数据库中实际存储的是最新版本的数据**。

在可重复读下，事务 A 启动时只能看到所有 A 启动前已提交的事务结果，而在 A 执行期间，尽管其他事务的更新对 A 是不可见的，但是 A 会根据数据库中存储的最新版本的数据及 undo log 计算出自己所需版本的数据，然后再进行操作。

一个数版本，对于一个事务视图而言，除了自己的更新总是可见，还有三种情况：

- 版本未提交，不可见
- 版本已提交
  - 在视图创建后提交，不可见
  - 在视图创建前提交，可见

实现：

InnoDB 为每个事务构造了一个数组，保存这个事务启动瞬间当前所有启动了尚未提交的的事务 ID。

- 低水位：数组中事务 ID 最小值
- 高水位：当前系统中已创建过的事务 ID 最大值加 1

事务启动的瞬间，一个数据版本的 row_trx_id 对比数组有三种情况：

- 落在低水位之前：这个数据版本是已提交的事务或当前事务自己生成的，该数据可见
- 落在高水位之后：这个数据版本是由当前事务之后启动的事务生成的，不可见
- 落在高低水位之间：
  - row_trx_id 在数组中，表示这个版本是由未提交的事务生成的，不可见
  - row_trx_id 不在数组中，表示这个版本是已提交的事务生成的，可见
    - 在范围内并不代表有，如 `12,13,15,16` 数组，id 为 14 的事务在当前事务启动之前已提交

所以一个事务的读数据流程：读取数据库存储的最新版本，得到其 row_trx_id，与当前事务的高低水位对比，如果该数据版本不可见，就找上一个历史版本，直到找到可见的数据版本。

这样的话，虽然期间这条数据被修改过，但事务无论何时查询，看到的数据结构都是一致的，所以称为**一致性读**。

## 更新逻辑

事务在更新数据时，不能在历史版本上更新的！即**更新数据都是先读后写的，而这个读，只能读当前最新的值，称为“当前读”（current read）**！

1. 事务 A 开启事务，此时一致性读视图看到的 k=1
2. 事务A 执行期间事务 B 将 k 修改为 2 并提交
3. 事务 A 将 k 加一：A 在最新版本数据 k=2 的基础上更新，完成后 k=3
   - 注：如果 A 还在 k=1 的基础上更新，那么 B 的更新就会丢失
4. 事务 A 查询 k 的值，发现 row_trx_id 是自己的事务 ID，所以查询到的 k 值为 3

注意：如果 select 语句加锁，也是当前读。

















