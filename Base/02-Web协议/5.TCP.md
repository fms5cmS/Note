
UDP（User Datagram Protocol 用户数据协议）和 TCP（Transmission Control Protocol 协议）是位于第四层传输层的协议。

TCP 协议是**面向连接的、可靠的、基于字节流**的传输层通信协议。而 UDP 则是分散的小数据包，是顺序发，乱序收。

TCP 连接是没有长短连接概念的！

TCP 协议在 IP 协议之上，解决网络通讯可依赖问题。
- 点对点(不能广播、多播)，面向连接
- 双向传递(全双工)
- 字节流，打包成报文段、保证有序接收、重复报文自动丢弃
  - 缺点：不维护应用报文的边界(对比 HTTP、GRPC)
  - 优点：不强制要求应用必须离散的创建数据块，不限制数据块大小
- 流量缓冲，解决速度不匹配问题
- 可靠的传输服务(保证可达，丢包时通过重发进而增加时延实现可靠性)
- 拥塞控制

TCP 协议的任务
- 主机内的进程寻址
- 创建、管理、终止连接
- 处理并将**字节(8bit)流**打包成报文段(如 IP 报文)
- 传输数据
- 保持可靠性与传输质量
- 流控制与拥塞控制

Q：如何标识一个 TCP 连接？

A：TCP 四元组(源地址，源端口，目的地址，目的端口)可以唯一的定义一个连接

> HTTP/3 的 QUIC 协议是通过连接 ID 来定义一个连接的。

TCP 的所有状态流转（含三次握手、四次挥手）：

![TCP 状态机](../../images/TCP-status.jpg)

# tcpdump 抓包

- `-D` 列举所有网卡设备
- `-i` 选择网卡设备
- `-c` 抓取多少条报文
- `--time-stamp-precision` 指定捕获时的时间精度，默认毫秒 micro，可选纳秒 nano 
- `-s` 指定每条报文的最大字节数，默认 262144 字节

> loopback 是还回地址的网卡设备

tcpdump 命令可以配合 BPF 来对抓包的数据做过滤：

```shell
$ tcpdump -i en0 -c 20 host www.bilibili.com and port 443
```

tcpdump 支持的文件操作：
- -w 输出结果至文件(可被 Wireshark 读取分析)
- -C 限制输入文件的大小，超出后以后缀加 1 等数字的形式递增。 注意单位是 1,000,000 字节
- -W 指定输出文件的最大数量，到达后会重新覆写第 1 个文件
- -G 指定每隔N秒就重新输出至新文件，注意 -w 参数应基于strftime 参数指定文件名
- -r 读取一个抓包文件
- -V 将待读取的多个文件名写入一个文件中，通过读取该文件同时读取多个文件

```shell
# 每个文件最大 1 个单位，最多 3 个文件，文件名称为 abc
# 最后会得到 abc0、abc1、abc2 三个文件
$ tcpdump -C 1 -W 3 -w abc
```

输出时间格式：
- -t 不显示时间戳
- -tt 自1970年1月1日0点至今的秒数 
- -ttt 显示邻近两行报文间经过的秒数
- -tttt 带日期的完整时间
- -ttttt 自第一个抓取的报文起经历的秒数

分析详情：
- -e 显示数据链路层头部
- -q 不显示传输层信息
- -v 显示网络层头部更多的信息，如 TTL、id 等
- -n 显示 IP 地址、数字端口代替 hostname 等
- -S TCP 信息以绝对序列号替代相对序列号
- -A 以 ASCII 方式显示报文内容，适用 HTTP 分析
- -x 以 16 进制方式显示报文内容，不显示数据链路层
- -xx 以 16 进制方式显示报文内容，显示数据链路层
- -X 同时以 16 进制及 ACII 方式显示报文内容，不显示数据链路层
- -XX 同时以 16 进制及 ACII 方式显示报文内容，显示数据链路层

# 三次握手

握手的目标：
- 同步 Sequence 序列号（ISN，Initial Sequence Number，初始序列号）
  - 每个 Number 都会标识一个字节，Server 端和 Client 端所使用的 ISN 都是不同的，所以需要通过握手来交换 ISN
- 交换 TCP 通讯参数，如 MSS（Maximum Segment Size 最大分段大小）、窗口比例因子、选择性确认、指定校验和算法

三次握手：SYN（同步），ACK（确认）

![三次握手](../../images/HTTP-TCPShakeHands.png)

注：图中第三次握手时，Client 不会发送 Seq 的，见下面抓包示例。

在本地 80 端口开启一个服务，然后抓包：

```shell
$ tcpdump -i lo0 port 80 -c 3 -S # 由于是本地访问本地开启的服务，所以这里对还回地址抓包，且仅抓取 3 个包，也就是前面的三次握手
# Client 发送了自己的 ISN 2825236013
21:27:41.240973 IP localhost.57316 > localhost.http: Flags [S], seq 2825236013, win 65535, options [mss 16344,nop,wscale 6,nop,nop,TS val 1702760285 ecr 0,sackOK,eol], length 0
# Server 会 ACK Client，同时发送自己的 ISN 774781734
21:27:41.241086 IP localhost.http > localhost.57316: Flags [S.], seq 774781734, ack 2825236014, win 65535, options [mss 16344,nop,wscale 6,nop,nop,TS val 3907779767 ecr 1702760285,sackOK,eol], length 0
# Client 会 ACK Server
21:27:41.241094 IP localhost.57316 > localhost.http: Flags [.], ack 774781735, win 6379, options [nop,nop,TS val 1702760285 ecr 3907779767], length 0
```

Q：为什么 Client 和 Server 发送的 ISN 都是随机数？

A：由于网络中报文会延迟、重发、丢失，为了防止这些异常情况对不同连接之间产生影响；同时也可以防止 sequence number attacks。

Sequence 序列号/Ack 序列号的设计目的是为了解决应用层字节流的可靠发送
- 跟踪应用层的发送端数据是否送达
- 确定接收端有序的接收到字节流
序列号的值针对的是字节而不是报文，序列号的值是和此报文包含的字节长度有关。
如：一个报文序号是100，字节数是50，那么确认序号只能是151，而不能是121或者131

## 状态变迁

三次握手共计涉及五种状态：CLOSE、LISTEN、SYN-SENT、SYN-RECEIVED、ESTABLISHED。

![三次握手的状态变迁](../../images/TCPShakeHands-status.jpg)

TCB（Transmission Control Block），保存连接使用的源端口、目的端口、目的 ip、序号、 应答序号、对方窗口大小、己方窗口大小、tcp 状态、tcp 输入/输出队列、应用层输出队 列、tcp 的重传有关变量等

使用 `netstat` 命令可以查看状态，不同 OS 命令参数有所区别。

服务端第一次收到客户端的 SYN 之后，会处于 SYN_RCVD 状态，此时双⽅还没有完全建立起连接，服务端会把这种状态下请求连接放在一个队列里，这种队列称之为半连接队列。
还有一个全连接队列，就是已经完成三次握⼿，建立起连接的就会放在全连接队列中。
如果队列满了了就有可能会出现丢包现象。

## 两次握手可以吗？

Q2：为什么需要三次握手，两次不可以吗？

三次握手是为了确认双方的收发能力是否正常。为什么需要三次才能确认？

1. 第一次握手后，服务端收到客户端的报文，服务端确认了客户端的发送、服务端的接收能力正常；
2. 第二次握手后，客户端收到了服务端的报文，客户端确认了服务端的接收、发送，以及自己的发送、接受能力正常，但此时服务端还无法确认客户端的接收能力是否正常；
3. 第三次握手后，服务端收到了客户端的 ACK，服务端确认了客户端的接收、发送正常，自己的发送、接受也正常。

三次握手不仅可以确认双方的收发能力正常；同时，三次握手的过程中，客户端和服务端会交换 ISN, 以便让对⽅知道接下来接收数据的时候如何按序列号组装数据。

## 可以携带数据吗？

第一、二次握手不可以携带数据，但第三次握手是可以携带数据的。

第三次握手前，客户端已处于 ESTABLISHED 状态，即对于客户端而言已经建立起连接了，而且也知道服务端的收发能力正常，所以可以携带数据。

第一次握手如果可以携带数据的话，假设有人恶意攻击服务器，每次在第一次握手的 SYN 报文中放入大量数据，并疯狂地重复发送，服务端会耗费大量时间和内存来接受这些报文的。

第二次握手是服务端发给客户端的，客户端无法携带数据。


# 重传&确认

TCP 是面向字节流的协议，不限制应用层传输消息的长度，但是在下面的网络层和数据链路层由于发送报文时使用的内存有限，它们会限制报文的长度，因此 TCP 必须把它从应用层收到的任意长度的字节流切分成许多个报文段 Segment。TCP 必须保证每个 Segment 一定会到达对方。TCP 是通过重传、确认来保证这一点的。

需要发送多个 Segment，但期间可能会发生报文丢失，如何解决？

PAR（Positive Acknowledgment with Retransmission）：每个 Segment 发送时会启动一个重传定时器，只有在重传定时器的时间内收到对方 ACK 后才发送下一个 Segment，如果重传定时器的时间内没有收到 ACK，就重发消息（会重置定时器）。效率低。

提升并发能力的 PAR：每个 Segment 发送时带上一个标识，ACK 的时候需要明确告知是对哪个 Segment 做 ACK 的，这样就可以并发发送多个 Segment，如果哪个 Segment 对应的定时器在时间内没有收到 ACK，就重发消息（会重置定时器）；接收方的内存和处理能力是有限的，发送方不能无限制的去并发发送，所以接收方每次 ACK 时还需要告诉发送方还剩下几个缓冲区。

> 上面的标识无法复用序列号，因为序列号是针对字节的，而非报文。

TCP 序列号是有限的，超过以后就会复用，但是复用可能会导致出现 PAWS (Protect Against Wrapped Sequence numbers) 序列号回绕问题：某个序列号被复用发送给接收方，而之前该序列号的消息由于网络问题导致重发，此时接收方就无法识别该序列号对应的实际消息是哪个了。

可以通过添加 TCP-timestamp 来解决，每次发送时携带上时间戳。

# 窗口

发送窗口反应了作为单 TCP 连接、点对点之间的流量控制模型，它是需要和接收端一起共同协调来调整大小的;而拥塞窗口则是反应了作为多个 TCP 连接共享带宽的拥塞控制模型，它是发送端独立地根据网络状况来动态调整的。

## 滑动窗口

滑动窗口机制是 TCP 的一种流量控制方法。如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。接收端的缓存传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow，流量控制解决的是这个问题。

TCP在进行数据传输的时候都是先将数据放在数据缓冲区中的，TCP维护了两个缓冲区
- 发送方缓冲区：发送方缓冲区用于存储已经准备就绪数据和发送了但是没有被确认的数据
- 接收方缓冲区：接收方缓冲区用于存储已经被接收但是还没有被用户进程消费的数据

发送窗口的四类数据：
1. 已发送并收到 Ack 确认的数据
2. 已发送未收到 Ack 确认的数据
3. 未发送但总大小在接收方处理范围内
4. 未发送但总大小超出接收方处理范围

其中 3 称为可用窗口，2、3 合起来称为为发送窗口。当把发送窗口的数据都发送出去后（未收到 ACK），可用窗口就耗尽了，但是发送窗口并没有变化；

当发送窗口的部分数据收到了 ACK 后，发送窗口移动。

![](../../images/TCP-window.jpg)

接收窗口的大小约等于对端发送窗口。

> 发送窗口和接收窗口是 TCP 连接的双方，一个作为生产者、一个作为消费者，为了达到一致协同的生产-消费速率，而产生的算法模型实现。

滑动机制
1. 发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界
2. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传；
3. 遵循快速重传、累计确认、选择确认等规则；
4. 发送方发的window size = 8192;就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。

## 拥塞控制

TCP 的生产者 - 消费者模型，只是在考虑单个连接的数据传递，但是，TCP 数据包是需要经过网卡、交换机、核心路由器等一系列的网络设备的，网络设备本身的能力也是有限的， 当多个连接的数据包同时在网络上传送时，势必会发生带宽争抢、数据丢失等。所以，TCP就必须考虑多个连接共享在有限的带宽上，兼顾效率和公平性的控制。

TCP 协议中，拥塞控制是通过拥塞窗口完成的，拥塞窗口的大小会随着网络状况实时调整。

- 慢启动算法：通过一定的规则，慢慢地将网络发送数据的速率增加到一个阈值，超过阈值后，慢启动就结束了。
- 拥塞避免算法：在这个阶段，TCP 会不断地探测网络状况，并随之不断调整拥塞窗口的大小。

所以，在任何一个时刻，TCP 发送缓冲区的数据是否能真正发送出去，至少取决于两个因素：当前的发送窗口大小；拥塞窗口大小。而 TCP 协议中总是取两者中最小值作为判断依据。

比如：当前发送的字节为 100，发送窗口的大小是 200，拥塞窗口的大小是 80，那么取 200 和 80 中的最小值，就是 80，当前发送的字节数显然是大于拥塞窗口的，结论就是不能发送出去。

## 小报文优化

小报文的传输的网络效率很低，因为每个 TCP Segment 都会有固定 20 字节的 TCP 头部，也会有固定 20 字节的 IP 头部，小报文传输时有效报文的比重很低。所以应在合理范围内避免大量传输小报文。

SWS(Silly Window syndrome)糊涂窗口综合症：如果应用层读取少量数据(如十几bytes)，接收端 TCP 有了少量的新的接收缓存后如果立即进行 window update 把新的 window size 通告发送端的话，发送端如果立即发送数据，那么接收端缓存可能又会立即耗尽，window size 又变为0，接着应用层重复读取少量数据，这个过程重复的话，那么发送端就会频繁的发送大量的小包。

SWS 的两个关键点：
1. 接收端告知了发送端比较小的 window size
2. 发送端收到较小的 window size 后立即响应发出了对应的小包

接收端优化：接收端需要在自己的缓冲区大到一个合理值之后再向发送端发送窗口更新通知；

发送端优化（Nagle 算法）：任何一个时刻，未被确认的小数据包（长度小于 MSS 的 TCP 分组）不能超过一个，在分组 ACK 到达之前不能发送其他的小分组，这样，发送端就可以把接下来连续的几个小数据包存储起来，等待接收到分组 ACK 后，再将数据一次性发送出去；

TCP delayed acknowledgment 延迟确认
- 当有响应数据要发送时,ack 会随着响应数据立即发送给对方
- 如果没有响应数据，ack 的发送将会有一个延迟，以等待看是否有响应数据可以一起发送
- 如果在等待发送 ack 期间，对方的第二个数据段又到达了，这时要立即发送 ack

> Nagle算法：是为了减少广域网的小分组数目，从而减小网络拥塞的出现。

Nagle 算法和延时确认算法一起使用会增大处理时延，如：
1. 客户端分两次将一个请求发送出去，由于请求的第一部分的报文未被确认，Nagle 算法开始起作用；
2. 同时延时 ACK 在服务器端起作用，假设延时时间为 200ms，服务器等待 200ms 后，对请求的第一部分进行确认；
3. 接下来客户端收到了确认后，Nagle 算法解除 请求第二部分的阻止，让第二部分得以发送出去，服务器端在收到之后，进行处理应答，同时将第二部分的确认捎带发送出去。

所以，在有些情况下 Nagle 算法并不适用，如对时延敏感的应用。除非有十足把握，否则不要轻易改变默认的 TCP Nagle 算法，可能禁用 Nagle 后，性能问题更严重了。

> 可以通过 TCP 套接字选项 TCP_NODELAY 禁用 Nagle 算法

# 四次握手关闭连接

关闭连接的目的：防止数据丢失；与应用层交互

四次握手：FIN（结束），ACK（确认）

![四次挥手](../../images/TCPWave-status.jpg)

MSL(Maximum Segment Lifetime) 报文最大生存时间，Linux 系统停留在 TIME_WAIT 的时间为固定的 60s。

TIME_WAIT 会维持 2MSL 时长的 TIME-WAIT 状态，保证至少一次报文的往返时间内端口是不可复用。

注：以上图为例，2MSL 时间是从 Client 收到 FIN 后发送 ACK 开始计时的！如果在 TIME_WAIT 时间内，由于 Client 的 ACK 没有传输到 Server，当 Client 收到 Server 重发的 FIN 报文时，2MSL 会重新计时。

TIME_WAIT 有保护作用：

假设 A 向 B 发送三个报文，其中 1、2 都被正常接收，而 3 由于网络延迟尚未到达 B，此时 B 发起关闭，如果 B 处于 TIME_WAIT 的时间很短或不存在，其他连接就会很快复用了端口并发送了报文，而此时 3 也发送过来了，就会对 B 造成数据错乱的影响。
假设 A 向 B 主动发起关闭，但是 A 最后的 ACK 报文传输失败，那么 B 就会重新发送 FIN 报文，如果 A 没有 TIME_WAIT 状态直接进入 CLOSED 状态，当 B 重发 FIN 报文时，A 就失去了当前状态的上下文，只能回复 B 一个 RST 操作，导致 B 出现错误。

## TIME_WAIT 遇到过的问题

在以前使用 [gorm](https://github.com/go-gorm/gorm) 的时候曾经遇到过服务频繁打印客户端 TIME_WAIT 的报错。是由于 `SetMaxIdleConns` 和 `SetMaxOpenConns` 两个设置的值相差较大，MaxIdleConns = 10，MaxOpenConns = 100，当用户请求数量多了的时候，每个 goroutine 会从连接池获取连接，如果没有可用的就会新建连接，用完后尝试归还到连接池，发现 MaxIdleConns 太小了，无法放到连接池中，于是就主动 close 连接。 谁先close，谁就有 TIME_WAIT。

解决方法：MaxIdleConns 调的大一些。

在 [分析golang sql连接池大量的time wait问题](https://xiaorui.cc/archives/5771) 中也有过同样的情况。

## TIME_WAIT 优化

主动发起关闭的一方会进入 TIME_WAIT 状态，通常持续该状态 2min 左右，也就是说，有 2min 的时间这个端口是被占用了的。

linux 下 TIME_WAIT 优化：tcp_tw_reuse

`net.ipv4.tcp_tw_reuse = 1` 开启后，作为客户端时新连接可以复用处于 TIME_WAIT 状态的端口

> 由于 timestamp 的存在，操作系统可以拒绝迟到的报文，需要通过 `net.ipv4.tcp_timestamps = 1` 启用！！

`net.ipv4.tcp_tw_recycle = 0` 开启后，同时作为客户端和服务器都可以使用 TIME-WAIT 状态的端口。但不安全，无法避免报文延迟、重复等给新连接造成混乱。所以该配置通常不应开启！！

`net.ipv4.tcp_max_tw_buckets = 262144` 配置 TIME_WAIT 状态连接的最大数量，超出后直接关闭连接。  

遇到异常状况时，可以通过 RST 复位报文直接关闭连接，绕过四次握手。

# Keep-Alive

TCP 有一个保持活跃的机制：Keep-Alive，默认关闭。

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文（数据非常少），如果连续几个探测报文都没有响应，则认为当前 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

时间段：`net.ipv4.tcp_keepalive_time`，默认 7200s = 2h
时间间隔：`net.ipv4.tcp _keepalive_intvl`，默认 75s
探测次数：`net.ipv4.tcp_keepalve_probes`，默认 9 次

开启后需要考虑：
1. 另一端正常工作。当发送 TCP 保活探测报文，对方正常响应，保活时间会被重置；
2. 另一端崩溃并重启。当发送 TCP 保活探测报文，对方响应，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接被重置；
3. 另一端崩溃，或另一端由于其他原因导致报文不可达。连续多次达到探测次数后，TCP 会报告该 TCP 连接已经死亡。

该机制可以分别在连接的两个方向上同时开启，也可以单独在一个方向上开启：
如果开启服务器端到客户端的检测，就可以在客户端非正常断连的情况下清除在服务器端保留的“脏数据”；
而开启客户端到服务器端的检测，就可以在服务器无响应的情况下，重新发起连接。

最少需要经过 2h + 9*75s = 2h 11min 15s 才能发现一个“死亡”的连接，对很多对时延要求敏感的系统中，这个时间间隔是不可接受的。







