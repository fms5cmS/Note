# 视图 view

视图是虚拟表，和普通表一样使用。通过表动态生成的数据 。

好处：重用 sql 语句；简化复杂的 sql 操作；保护数据，提高安全性。

应用场景：多个地方用到同样的查询结果；该查询结果使用的sql语句较为复杂。

|       | 关键字          | 是否实际占用物理空间              | 使用                         |
| ----- | --------------- | --------------------------------- | ---------------------------- |
| view  | ` create view ` | 只是保存了sql逻辑，不保存查询结果 | 增删改查，只是一般不能增删改 |
| table | `create table`  | 保存了数据                        | 增删改查                     |

**对视图的插入、修改、删除，也会反映到原来的表中。一般而言不会对视图进行这些操作，会将视图设置为只读。**

删除视图：`DROP VIEW view1 view2 ...`

查看视图：`DESC view1`  或 `SHOW CREATE VIEW view1`



## 创建

```sql
CREATE VIEW 视图名 AS 查询语句;
```

案例：查询姓张的学生名和专业名

```sql
CREATE VIEW v1 AS
	SELECT stuname,majorname
	FROM stuinfo s
	INNER JOIN major m ON s.majorid= m.id;

-- 以后再使用的话：
SELECT * FROM v1 WHERE stuname LIKE '张%';
```



## 修改

- 有就修改，没有就创建

```sql
CREATE OR REPLACE VIEW 视图名 AS 查询语句;
```

- 直接修改

```sql
ALTER VIEW 视图名 AS 查询语句;
```

案例：

```sql
CREATE OR REPLACE VIEW myv3 AS
	SELECT AVG(salary),job_id FROM employees
	GROUP BY job_id;
```

```sql
ALTER VIEW myv3 AS SELECT * FROM employees;
```



## 更新

视图的可更新性和视图中查询的定义有关系，有以下特点的视图是**不能更新**的：

1. 有分组函数、`distinct`、`group  by`、`having`、`union`或`union all`的sql语句

```sql
CREATE OR REPLACE VIEW myv1 AS
	SELECT MAX(salary) m,department_id FROM employees
	GROUP BY department_id;
-- 更新
UPDATE myv1 SET m=9000 WHERE department_id=10;     -- 失败
```

2. 常量视图

```sql
CREATE OR REPLACE VIEW myv2 ASSELECT 'john' NAME;
-- 更新
UPDATE myv2 SET NAME='lucy';            -- 失败
```

3. Select中包含子查询

```sql
CREATE OR REPLACE VIEW myv3 AS
	SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资
	FROM departments;
-- 更新
UPDATE myv3 SET 最高工资=100000;         -- 失败
```

4. join

```sql
CREATE OR REPLACE VIEW myv4 AS
	SELECT last_name,department_name FROM employees e
	JOIN departments d ON e.department_id  = d.department_id;
-- 更新
UPDATE myv4 SET last_name  = '张飞' WHERE last_name='Whalen';-- 成功
INSERT INTO myv4 VALUES('陈真','xxxx');         -- 失败
```

5. from一个不能更新的视图 

```sql
CREATE OR REPLACE VIEW myv5 AS SELECT * FROM myv3;
-- 更新
UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;   -- 失败
```

6. where子句的子查询引用了from子句中的表

```sql
CREATE OR REPLACE VIEW myv6 AS
	SELECT last_name,email,salary FROM employees
	WHERE employee_id IN(
    SELECT  manager_id FROM employees
    WHERE manager_id IS NOT NULL
  );
-- 更新
UPDATE myv6 SET salary=10000 WHERE last_name = 'k_ing';   -- 失败
```



# 流程控制

## 分支

- if 函数：`if(表达式1，表达式2，表达式3)`，

表达式1成立则返回表达式2的值，否则返回表达式3的值。

------

- if 结构：只能应用在 begin end 中 

```sql
IF 条件1 THEN 语句1;
ELSEIF 条件2 THEN 语句2;
....
ELSEIF 语句n;
END IF;
```

案例：

```sql
-- 创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回D
DELIMITER $;
CREATE FUNCTION test_if(score INT) RETURNS CHAR
BEGIN
	IF score>=90 AND score<=100 THEN RETURN 'A';
	ELSEIF score>80 THEN RETURN 'B';
	ELSEIF score>60 THEN RETURN 'C';
	ELSE RETURN 'D';
	END IF;
END $;
```

------

case 结构：如果 then 后面时语句，则必须加分号，且 end 后面要有 case。如果是返回值，则不必加分号，且end 后面没有 case。

- 可以作为表达式，嵌套在其他语句中使用，放在任何地方；

- 也可以作为独立的语句去使用，只能放在` BEGIN END`中。

- `ELSE` 可以省略，如果省略，且所有的`WHEN`条件都不满足，则返回 NULL。

情况一：类似于 switch 语句，一般用于实现等值判断

```sql
case 变量或表达式
  when 值1 then 返回的值1或语句1;
  when 值2 then 返回的值2或语句2;
  ...
  else 返回的值n或语句n;
end case ;

-- 示例
SELECT salary 原始工资,department_id,
  CASE department_id
    WHEN 30 THEN salary*1.1   -- 部门号=30，显示的工资为1.1倍
    WHEN 40 THEN salary*1.2   -- 部门号=40，显示的工资为1.2倍
    WHEN 50 THEN salary*1.3   -- 部门号=50，显示的工资为1.3倍
    ELSE salary               -- 其他部门，显示的工资为原工资
  END AS 新工资
FROM employees;
```

情况二：类似于多重 if 语句，一般用于实现区间判断

```sql
case
when 条件1 then 返回的值1或语句1;
when 条件2 then 返回的值2或语句2;
...
else 语句n;
end case;

-- 示例
SELECT salary,
CASE
WHEN salary>20000 THEN 'A'   -- 如果工资>20000,显示A级别
WHEN salary>15000 THEN 'B'   -- 如果工资>15000,显示B级别
WHEN salary>10000 THEN 'C'   -- 如果工资>10000，显示C级别
ELSE 'D'                     -- 否则，显示D级别
END AS 工资级别
FROM employees;
```



## 循环

循环控制：需要搭配标签使用。

`iterate` 类似于 continue，继续，结束本次循环，继续下一次；

`leave` 类似于 break，跳出，结束当前所在的循环。

- while：先判断后执行，仅用在`begin end`中 

```sql
[标签:]while 循环条件 do
	循环体;
end while [标签];
```

- repeat：先执行后判断，仅用在`begin end`中

```sql
[标签] repeat
	循环体;
until 结束循环的条件
end repeat [标签];
```

- loop：没有条件的死循环，仅用在`begin end`中

```sql
[标签:] loop
	循环体;
end loop [标签];
```

------

案例：

```sql
#案例：批量插入，根据次数插入到admin表中多条记录
CREATE PROCEDURE pro_while1(IN insertCount INT)
BEGIN
	DECLARE i INT DEFAULT 0;
	WHILE i< insertCount DO
		INSERT INTO admin(name,pwd) VALUES(CONCAT('Rose',i),'666');
		SET i=i+1;
	END WHILE;
END $;

CALL pro_while1(100) $;
```

使用 leave：

```sql
#案例：批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止
TRUNCATE TABLE admin$;
DROP PROCEDURE pro_while1$;
CREATE PROCEDURE test_while1(IN insertCount INT)
BEGIN
	DECLARE i INT DEFAULT 0;
	a:WHILE i<insertCount DO
		INSERT INTO admin(name,pwd) VALUES(CONCAT('bx',i),'41');
		IF i>=20 THEN LEAVE a;
		END IF;
		SET i=i++1;
	END WHILE a;
END $;

CALL test_while1(100) $;
```

使用 iterate：

```sql
#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次
TRUNCATE TABLE admin$
DROP PROCEDURE test_while1$
CREATE PROCEDURE test_while1(IN insertCount INT)
BEGIN
	DECLARE i INT DEFAULT 0;
	a:WHILE i<=insertCount DO
		SET i=i+1;
		IF MOD(i,2)!=0 THEN ITERATE a;
		END IF;
		INSERT INTO admin(name,pwd) VALUES(CONCAT('bx',i),'0000');
	END WHILE a;
END $

CALL test_while1(100)$
```



# 存储过程&函数

存储过程和函数：类似于java中的方法。

存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新；

函数：有且仅有1 个返回，适合做处理数据后返回一个结果



## 变量

- 系统变量：全局变量；会话变量。

注意：全局变量要添加 `global` 关键字，会话变量要添加 `session` 关键字，如果不任何关键字，默认会话级别。

全局变量：对于所有会话（连接）有效，但不能跨重启。使用：

```sql
-- 1.查看所有全局变量
SHOW GLOBAL VARIABLES;
-- 2.查看满足条件的部分全局变量
SHOW GLOBAL VARIABLES LIKE '%char%'
-- 3.查看指定的全局变量的值
SELECT @@GLOBAL.autocommit;
-- 两种方式为全局变量赋值：
SET @@GLOBAL.autocommit=0;
SET GLOBAL autocommit=0;
```

会话变量：对于当前会话（连接）有效。使用时对应上面四步：

```sql
-- 1.查看所有会话变量
SHOW [SESSION] VARIABLES;
-- 2.查看满足条件的部分会话变量
SHOW [SESSION] VARIABLES LIKE '%char%';
-- 3.查看指定的会话变量的值
SELECT @@autocommit;  -- 或 SELECT @@SESSION.tx_isolation;
-- 两种方式为会话变量赋值：
SET @@SESSION.tx_isolation='read-uncommitted';
SET SESSION tx_isolation='read-committed';
```

---

- 自定义变量：用户变量；局部变量。

|      | 作用域                | 定义位置              | 语法                        |
| ---- | --------------------- | --------------------- | --------------------------- |
| 用户 | 当前会话              | 会话的任何地方        | 必须加`@`符号，不用指定类型 |
| 局部 | 定义它的`BEGIN END`中 | `BEGIN END`的第一句话 | 一般不用加`@`，需要指定类型 |

用户变量的使用：

```sql
-- 1.声明并初始化（三种方式，也可用于赋值）
SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;
-- 2.赋值
#方式一：通过SET或SELECT，同上面的声明并初始化
#方式二：通过SELECT INTO
SELECT 字段 INTO @变量名 FROM 表;  #将查询到的结果赋值给变量
-- 3.使用（查看变量的值）
SELECT @变量名1，@变量名2;
```

局部变量的使用：

```sql
-- 1.声明（两种方式）
DECLARE 变量名 类型;
DECLARE 变量名 类型 [DEFAULT 值];
-- 2.赋值（同用户变量的赋值）
-- 3.使用（查看变量的值）
SELECT 局部变量名;
```



## 存储过程

存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新。

- 创建：需要在命令行创建

```sql
CREATE PROCEDURE 存储过程名(参数列表)
BEGIN
    存储过程体（一组合法的SQL语句）
END
```

参数列表有三部分：参数模式、参数名、参数类型。eg：`in stuname varchar(20)`

参数模式：

1. `in`：该参数需要调用方传入值。 
2. `out`：该参数可以作为返回值。
3. `inout`：该参数既可作为输入又可作为输出，也就是该参数既需要传入值，又可以返回值。

存储过程体仅仅只有一句话，`begin end`可以省略；

存储过程体中的每条sql语句的结尾要求必须加分号；

存储过程的结尾可以用`delimiter 结束标记`重新设置，如：`delimiter $`；

- 调用：需要在命令行使用

```sql
 CALL 存储过程名(实参列表)  结束标记；
```

- 删除存储过程：一次只能删除一个

```sql
DROP PROCEDURE 存储过程名
```

- 查看存储过程的信息 

```sql
DESC myp2;  -- 错误
SHOW CREATE PROCEDURE  myp2;
```

---

案例：

空参列表

```sql
-- 案例：插入到admin表中五条记录
-- 设置结束标记,一般情况下结束标记为分号，但由于存储过程和函数中会有多行多个分号，为了在创建时不会将存储过程或函数的内容分开，故定义了一个新的结束标记
DELIMITER $;   
-- 1.创建
CREATE PROCEDURE myp1()
BEGIN
	INSERT INTO admin(username,`password`) 
	VALUES('bx','12541'),('zzk','132128'),
				('zf','132133'),('gl','132118'),
				('yg','132109');  #插入5条记录
END $
-- 2.调用
CALL myp1() $;
-- 3.查看
SELECT * FROM admin $;
```

带 IN 模式参数

```sql
-- 案例：创建存储过程实现，用户是否登录成功
DELIMITER $;
-- 这里有两个 IN 模式的参数
CREATE PROCEDURE myp3(IN username VARCHAR(10),
                      IN `password` VARCHAR(10))
BEGIN
	-- 声明一个局部变量来保存结果，并初始化
	DECLARE result INT DEFAULT 0; 
	-- 赋值
	SELECT COUNT(*) INTO result FROM admin
  WHERE admin.username=username AND admin.`password`=`password`;
  -- 使用
	SELECT IF(result>0,'成功','失败'); 
END $

CALL myp3('zzk','132128')$;  -- 调用
```

带 OUT 模式参数（不用return语句，会自动返回）

```sql
-- 案例：根据输入的女神名，返回对应的男神名
DELIMITER $;
CREATE PROCEDURE myp4(IN beautyName VARCHAR(20),
                      OUT boyName VARCHAR(20))
BEGIN
	SELECT bo.boyName INTO boyName
	FROM boys bo JOIN beauty b ON bo.id=b.boyfriend_id
	WHERE b.name=beautyName;
END $
-- 设置一个用户变量来接收返回值。也可以不设置，直接写下面的调用语句
SET @bName='' $; 

CALL myp4('bx',@bName)$;  -- 调用
SELECT @bName$;        -- 查看存储过程的返回值
```

带 INOUT 模式参数

```sql
-- 案例：传入a和b两个值，最终a和b都翻倍并返回
DELIMITER $;
CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)  #都是局部变量
BEGIN
	SET a=a*2;
	SET b=b*2;
END $

SET @m=10$;        -- 定义两个用户变量
SET @n=20$;
CALL myp8(@m,@n)$;   --调用
SELECT @m,@n$;  -- 查看存储过程的返回值
```



## 函数

函数：有且仅有1 个返回，适合做处理数据后返回一个结果。

- 创建：

```sql
CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型
BEGIN
	函数体
END
```

参数列表有两部分：参数名 参数类型；

函数体：肯定会有return语句，如果没有会报错。如果return语句没有放在函数体的最后也不报错，但不建议 return 值；

函数体中仅有一句话，则可以省略begin end；

使用 delimiter 语句设置结束标记。

- 调用：

```sql
SELECT 函数名(参数列表)
```

- 删除：

```sql
DROP FUNCTION myf3; 
```

- 查看：

```sql
SHOW CREATE FUNCTION myf3;
```

---

案例：

无参有返回

```sql
-- 案例：返回公司的员工个数
DELIMITER $;
CREATE FUNCTION myf1() RETURNS INT
BEGIN
	-- 定义了一个局部变量
	DECLARE result INT DEFAULT 0;
	-- 赋值
	SELECT COUNT(*) INTO result FROM employees;
	RETURN result;
END $;

SELECT myf1() $;
```

有参有返回

```sql
-- 案例1：根据员工名，返回它的工资
DELIMITER $
CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE
BEGIN
	-- 定义了一个用户变量
	SET @msalary=0;
  -- 赋值
	SELECT salary INTO @msalary FROM employees 
		WHERE last_name=empName;
	RETURN @msalary;
END $

SELECT myf2('ernst') $
```
