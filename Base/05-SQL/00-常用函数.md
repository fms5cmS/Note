# 单行函数

单行处理函数：一行记录对应一个输出。 

调用：`SELECT 函数名(实参列表) [FROM 表名];`



## 字符相关

```sql
-- 字符串拼接 CONCAT
SELECT CONCAT(first_name,'-',last_name) 姓名 FROM employees;

-- length 获取字节个数：UTF-8的一个汉字占3个字节；GBK则是2个
-- 去前后指定的空格和字符 TRIM
SELECT LENGTH(TRIM('    张翠山    '))；      输出9
SELECT TRIM('a' FROM 'aaaaaa张aaaaa三aaaaaaa') --输出：张aaaaa三

-- 截取子串 SUBSTR(字符串，起始下标，截取长度)，若不写截取长度，从起始下标开始全截取
-- 注意：索引从1开始!
#截取从指定索引处后面所有字符
SELECT SUBSTR('abcdefghijk',7) ;
#截取从指定索引处指定字符长度的字符
SELECT SUBSTR('abcdefghijk',1,3);
```

```sql
-- 转为大写 UPPER  转为小写 LOWER
#将姓变大写，名变小写，然后拼接:
SELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;
```

```sql
-- 去左边空格 ltrim
-- 去右边空格 rtrim
-- 替换 REPLACE
SELECT REPLACE('abcdefg','fg','~~')  # 输出：abcde~~

-- lpad 用指定的字符实现左填充指定长度（最后的长度一定是指定的长度，不足则补充，超出则从左开始删除直到长度达到）
-- rpad 用指定的字符实现右填充指定长度 
SELECT LPAD('XXX',10,'*') ;	#输出：*******XXX
SELECT RPAD('XXX',12,'ab') ; #输出：XXXababababa

-- instr 返回子串第一次出现的索引
SELECT INSTR('abcdefg','bx')；  #输出 0
```



## 数学相关

- round 四舍五入（理解：先对绝对值四舍五入，再加上正负号） 

  ```sql
  SELECT ROUND(-1.55);      #输出：-2
  SELECT ROUND(1.567,2);    #输出：1.57    指定小数点位数，默认为0
  ```

- rand 随机数

- floor 向下取整，返回<=该参数的最大整数 

  ```sql
  SELECT FLOOR(-9.99);  #输出 -10
  ```

- ceil 向上取整,返回>=该参数的最小整数 

  ```sql
  SELECT CEIL(-1.02);  #输出 -1
  ```

- mod 取余（被除数如果为正结果为正，被除数为负，结果为负）   mod（a,b）：相当于java中的计算过程：a-a/b*b 

  ```sql
  mod(-10,-3):     #输出：-1               -10- (-10)/(-3)*（-3）=-1
  ```

- truncate 截断 

  ```sql
  SELECT TRUNCATE(1.69999,1);     #输出：1.6     指定小数点后位数
  ```



## 日期函数 

- now 当前系统日期+时间，返回当前系统日期+时间 

  ```sql
  SELECT NOW();
  ```

- curdate 当前系统日期，不包含时间

- curtime 当前系统时间，不包含日期

- str_to_date 将字符转换成日期

- date_format 将日期转换成字符

**MySQL的日期格式：%Y-%m-%d-%H-%i-%s  年月日时分秒**



- `str_to_date('日期字符串','日期格式')`：将字符串转成日期（DATE类型） 

案例：查询出1981-12-17入职的员工 

```sql
#由于输入的日期字符串与MySQL中默认的日期格式（%Y-%m-%d）相同，存在自动类型转换，所以可以查询出结果。
SELECT name,hiredate FROM emp WHERE  hiredate = '1981-12-17';     
#可以查询出结果
SELECT name,hiredate FROM emp WHERE  hiredate = str_to_date('12-17-1981', '%m-%d-%Y');   
```

说明：

```sql
INSERT INTO student(birth) VALUES('1995-01-17'); #可以成功插入是因为输入的日期字符串与MySQL中默认的日期格式（%Y-%m-%d）相同，存在自动类型转换
INSERT INTO student(birth) VALUES( str_to_date('01-17-1995','%m-%d-%Y') );
```

java中：日期格式：yyyy-MM-dd-HH-mm-ss-sss   年-月-日-时-分-秒-毫秒 

```java
//字符串转日期：
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
Date date = sdf.parse("1995-02-18");
```



---

- `date_format('日期类型数据','日期格式')`：将日期转成具有特定格式的字符串

案例：

```sql
#查询员工的入职日期，以‘12-26-1996’的格式显示 
SELECT name, date_format(hiredate , '%m-%d-%Y')  hiredate FROM emp ;
#查询员工的入职日期，以‘12/26/1996’的格式显示
SELECT name, date_format(hiredate , '%m/%d/%Y')  hiredate FROM emp ;
```

```sql
-- 默认将date类型转成字符串类型，格式为‘%Y-%m-%d’ 
SELECT hiredate FROM emp； 
```

java中日期格式化： 

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date nowTime = new Date();
String strTime = sdf.format(nowTime);
```



## 其他函数

- version 版本

- database 当前库

- user 当前连接用户

- ==ifnull 可以将null 转换成一个具体值。ifnull(col_name , s )如果某一列为空，显示为s==

  ```sql
  select name , ifnull(email,'no email')  email from students; #将email为空的显示为 no email
  
  ```



# 多行处理函数

多行处理函数：多行记录处理后得到一个输出。也叫分组函数/聚合函数。

功能：用作统计使用 

特点：

- 会自动忽略空值NULL，除了`count(*)`；

- sum和avg一般用于处理数值型； max、min、count可以处理任何数据类型；

- 都可以搭配distinct使用，用于统计去重后的结果； 

  ```sql
  SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;
  SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;
  
  ```

- count的参数可以支持：字段、`*`、常量值，一般放1。一般使用`count（*）`函数用于统计行数

- 和分组函数一同查询的字段要求是 `group by `后的字段 

| 函数    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| sum()   | 求和                                                         |
| avg()   | 取平均                                                       |
| max()   | 取最大的数                                                   |
| min()   | 取最小的数                                                   |
| count() | 取得记录数，参数可以是字段名，也可以是` *`。字段名：该字段中元素不为NULL的记录总数`*`：满足条件（WHERE语句）的所有记录总数，无论是否为NULL |

- 分组函数不能直接使用在WHERE语句中 

  ```sql
  #找出工资在平均工资以上的员工
  SELECT name,salary FROM emp WHERE salary>avg(salary);错误
  
  ```

- 和分组函数一同查询的字段有限制 

  ```sql
  SELECT AVG(salary),employee_id  FROM employees;      #语法正确，但第二个字段查询没有意义了。分组函数得到的是一行结果，而第二个字段查询需要得到的是多行结果
  
  ```
