- collector 指垃圾收集器；
- mutator 指垃圾收集器外的部分，如应用程序本身；
- 根对象 roots 是堆之外且能被程序访问到的，如栈上的对象等。
  - Java 中可作为根对象的有：
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象；
    - 方法区中类静态属性引用的对象；
    - 方法区中常量引用的对象；
    - 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。
  - Golang 的根对象是协程栈上的指针对象



# 谁“死”了？

垃圾收集器在对堆内存进行回收前，首先要判断哪些对象还“存活着”，哪些对象已经“死”（不可能再被任何途径使用）了。

- 引用计数法（Reference Counting）
  - 给对象中添加一个引用计数器，每当有被引用一次，计数器值加一，当引用失效时，计数器值减一。任何时刻计数器值为 0 的对象就是不可能再被使用的。
  - 优点：实现简单，判定效率高。
  - 缺点：很难解决对象之间循环引用的问题。
- **可达性分析算法**（Reachability Analysis）
  - 以根对象开始扫描，遍历堆上的对象，当根对象指向堆上的某个对象，就说明这个对象是可达的，否则就是不可达的。
  - 遍历过的路径称为引用链(Reference Chain)。
  - 注意：进行可达性分析时要让整个系统冻结在某个时间点上，对外表现为所有工作进程都停止下来。是为了让可达性分析算法准确获取到根对象。





# 常见 GC 策略

## Mark-Sweep

标记-清除算法：

1. 触发 GC 事件发生，一般是申请堆内存时或定时回收；
2. STW(Stop The World)，挂起整个程序，等待 GC；
3. 从根对象开始扫描，在每个可达对象的 header 做一个标记；
4. 清除。扫描整个堆，发现是可达对象(根据 header 标志)，清楚掉其标志位即可，如果是不可达对象，则把对象作为分块，连接到被称为“空闲链表”的单向链表。之后进行分配时只要遍历这个空闲链表就可以找到分块。

优点：易实现

缺点：

- 效率问题：标记和清除两个过程的效率都不高；
- 空间问题：导致内存的碎片化，从而不连续。当需要分配较大对象时，如果无法找到足够的连续内存而不得不触发另一次 GC。
- STW



## Copying

复制算法：

1. 将堆内存按容量分为大小相等的两块，一个叫 From、一个叫 To；
2. From 内存块就是内存分配时用的；
3. 当进行 GC 时，将活跃的对象直接复制到 To 内存中，然后把 To 空间作为程序使用的空间，再把 From 清空，将其作为 To 空间。

优点：

- 分配速度快，没有空闲链表的概念，直接当作一个占内存分配即可，没有碎片化问题
- 吞吐量高，也就是 GC 速度快，不需要区扫描所有的堆
- 通过老空间的内容复制到新空间后，相互有引用的对象会被分配在距离较近的地方，可以提高缓存命中率

缺点：

- 内存浪费，将使用内存缩小为原来的一半
- 复制清除的过程需要 STW



## Mark-Compact

标记整理算法：

1. 标记所有需要回收的对象；
2. 让所有存活对象都向内存的一端移动；
3. 清理掉边界外的内存。



## Generational Collection

分代收集只是一种思想，并非一个专门的垃圾回收算法。可以根据对象存活周期的不同将内存划分为几块，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。JVM 就是使用的分代收集算法。

Java 堆可细分为：新生代（Eden 空间、From Survior 空间、To Survior 空间）和老年代。

- 新生代：采用复制(Copying)算法。
- 老年代：采用标记-清除(Mark-Sweep)算法 或 标记整理(Mark-Compact )算法。

步骤：

1. 所有新生成的对象首先都是放在Eden区；
2. Eden 区满（达到一定比例）后触发一次 Minor GC ，清理掉无用对象（大量）；
3. 将存活的对象复制到其中一个 Survior 区（如 From Survior区），并清空 Eden 区；
4. 当 Eden 区再次满了，触发一次Minor GC；
5. 把 From Survior 区和 Eden 区的存活对象都复制到 To Survior 区，并清空 From Survior 区和Eden区；（每次只有一个 Survior 区在使用）
6. 重复多次 4、5步操作（默认 15 次），Survivor 中没有被清理的对象，则会复制到老年代Old(Tenured)区中，；
7. 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC）。

常见的 GC：

- Minor GC：用于清理新生代区域，Java对象生存周期都很短，所以Minor GC非常频繁，速度一般也很快；
- Major GC：用于清理老年代区域。
- Full GC：用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 

如下原因可能导致 Full GC：　　

- 年老代(Tenured)被写满　　
- 持久代(Perm)被写满　　
- `System.gc()`被显式调用（程序建议 GC 启动，不是调用 GC）　　
- 上一次 GC 之后 Heap 的各域分配策略动态变化 



## tri-color mark

[Visualizing Garbage Collection Algorithms](https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/)

[Garbage Collection In Go](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html)

Golang 1.5 前主要采用 Mark-Sweep 算法，STW 时间会很长，1.5 及之后采用三色标记法。

三色标记法是在 Mark-Sweep 上发展来的，尽量把标记阶段、清除阶段与程序同时跑。

GC 开始时，所有对象默认都是白色，之后，所有可达的对象都会被标记为黑色，而灰色是中间状态。

1. GC 触发时，初始化写屏障(Write barrier)。写屏障就是记录第一次扫描时漏掉的那些对内存的操作，这一过程会进行 STW，但时间很短；
2. 垃圾收集器会从根对象开始扫描，把所有的垃圾根对象压入一个栈中，并将其都标记为灰色；
3. 从栈中 pop 出一个对象，把该对象指向的所有子对象也入栈(并标记为灰色)，将 pop 出的对象标记为黑色，然后放入黑色的对象集合中；
4. 重复上一步，直到栈为空；
5. 扫描所有的堆，把白色对象清除即可。

注意：

如果有新创建的对象，而指向该对象的是黑色的对象，或者指向该对象的恰好也是刚创建的根对象，那这个刚创建的对象会被漏标记；

如果某个白色对象在被灰色对象引用的情况下，改为被黑色对象引用了，而黑色对象其实已经被扫描过了，这样这个白色对象就不会被标记到。

遇到以上两种情况就要用到写屏障，只要指向的对象是白色的，就把它标记为灰色！

优点：STW 时间很短

缺点：吞吐量低，因为有写入屏障



