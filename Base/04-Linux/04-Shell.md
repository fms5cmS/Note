查看 /etc/shells 文件，可以知道 Linux 可用的 shells，Linux 预设使用 /bin/bash。

如果读取到一个 Enter 符号 (CR) ，就尝试开始执行该行 (或该串) 命令；

如果一行的内容太多，则可以使用 \【Enter】来延伸至下一行；

- 命令别名设定功能：给常用指令设定别名
  - eg：`alias lm='ls -al'`，此时就可以使用`lm`代替`ls -al`指令；
  - 直接输入`alias`查看当前的命令别名；
  - eg：`unalias lm`取消别名
- 通配符（Wildcard）
  - `*`：任意多个任意字符
  - `?`：一定有一个任意字符。eg：`ll -d /etc/?????`找出 /etc/ 下文件名刚好是五个字母的文件名
  - `[]`：一定有一个在括号内的字符(非任意字符)。eg：`[abcd]`一定有a、b、c、d中的一个字符
  - `[-]`：若有减号在中括号内时，代表在编码顺序内的所有字符。eg：`[0-9]`代表 0 到 9 之间的所有数字
  - `[^]`：若中括号内的第一个字符为`^`，那表示反向选择，例如`[^abc]`代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。

在命令行中：`bash`进入子程序；`exit`离开当前子程序

shell脚本用在系统管理上是很好的一项工具，但用在处理大量数值运算上，性能就不够了，因为它的速度较慢，且使用的CPU资源较多，造成主机资源的分配不良。

- 注释方式：


```shell
#  单行注释
:<<!
	多行注释
!
```

- 第一行必须是：`#!/bin/bash`。该文件内的语法用bash的语法，执行时，就可以加载bash的相关环境配置文件。
- 返回值：利用`exit`指令来中断程序，并返回一个数值给系统。
- 需要有可执行权限：eg：`chmod 744 hello.sh`

# 执行脚本的四种方式

```shell
#!/bin/bash
cd tmp
pwd
```

- `bash filename.sh` 或 `sh filename.sh`使用 bash 来运行，只要有 r 权限即可，没有 x 权限也可以运行
  - 文件中的 `#!/bin/bash` 是注释
  - 在当前终端下产生一个名为 bash 的子进程（子 shell），在子进程中再运行脚本
  - 代码输出结果为 /tmp，但脚本执行结束后当前目录又会回到原本的目录
- `./filename.sh`  使用系统自带的 shell 来解析。需要 rx 权限
  - 文件中的 `#!/bin/bash` 就是在告诉系统要用 /bin/bash 来运行，该行是非注释的形式
  - 也是产生一个子进程再去运行脚本
  - 代码运行结果同上
- `source filename.sh`
  - 直接在当前进程中运行
  - 代码输出结果为 /tmp，脚本执行结束后当前目录也变更为 /tmp
- `. filename.sh`
  - 直接在当前进程中运行
  - 代码运行结果同上
- `filename.sh` 如果该脚本是在命令搜索路径 `$PATH` 下，则可以运行，否则即使在脚本所在目录下执行也无法运行

内建命令的结果不会传递给子 shell ！

# 管道&重定向

## 管道

管道和信号一样，也是进程通信的方式之一。

管道符 `|`：给 `|` 两边的命令（如果是外部命令的话）各自创建一个子进程，再把第一个命令的输出和第二个命令的输入建立连接

由于是在子进程中运行的，所以在子进程中如果有内建命令的话，是不会传递给父进程的，所以在使用管道符时，尽量避免使用内建命令，如果需要使用内建命令，将其放到封装好的 shell 脚本中。

## 筛选命令

结合管道符一起使用

- `cut`指令：将同一行里面的数据进行分解！
- `-d`：后接分隔字符，与`-f`一起使用
  - `-f`：依据`-d`的分隔字符将一段讯息分区成为数段，用`-f`取出第几段的意思
- `-c`：以字符为单位取出固定字符区间

```shell
 echo "1;2;3;4;5" | cut -d ';' -f 2，4   #输出 2;4
 echo "1;2;3;4;5" | cut -c 2-5      #输出 ;2;3
 echo "1;2;3;4;5" | cut -c 2-		#输出 ;2;3;4;5
```

---

- `grep [选项] 查找内容 源文件`：过滤查找分析**一行**讯息
  - `-a`：将 binary 文件以 text 文件的方式查找数据

  - `-c`：计算找到所需数据的次数

  - `-n`：显示匹配行及行号

  - `-i`：忽略字母大小写

  - `-v`：反向查找

```shell
last | grep 'root'   # 将 last 中，出现 root 的每一行都取出来。last可得到登入主机者的身份
last | grep -v 'root' # 如果某行没有 root 就将那一行取出来
```

## 重定向

一个进程默认会打开标准输入、标准输出、错误输出三个文件描述符：

1. 标准输入（standard input）：代码为0，使用`<`或`<<`；（默认通过键盘等终端输入）
2. 标准输出（standard output）：代码为1，使用`>`或`>>`；（将正确的数据默认输出到终端）
3. 标准错误输出（standard error）：代码为2，使用`2>`或`2>>`。（将错误的数据默认输出到终端）

- 输入重定向（利用文件代替终端进行输入）：`<`、`<<`
  - `read var < /path/to/a/file` 
  - `<<` 指定输入结束的字符
  - `cat > file << "EOF"` 用键盘向 file 输入内容，键盘输入 EOF 即代表中断输入
- 输出重定向（利用文件作为输出端）：`>`、`>>`、`2>`、`&>`
  - `echo 123 > /path/to/a/file`
  - `cat > file` 使用键盘输入内容到 file（file 会自动创建） 中，需要通过 Ctrl+D 来中断键盘输入
  - `>` 会覆盖目标文件的所有内容，`>>` 是追加到目标文件已有内容的后面
  - `2>` 是对文件描述符 2 的操作，当前命令如果产生错误，将错误信息输出到文件中
  - `&>` 命令执行的结果或错误都输出到文件中
  - `/dev/null` 作为输出端可以吃掉任何导向该终止的信息
    - `find /home -name .bashrc 2> /dev/null` 会将错误的数据丢弃

```shell
#!/bin/bash
cat > /root/a.sh <<EOF
echo "hello bash"
EOF
```

执行以上脚本后，查看 a.sh 发现里面的内容为 `echo "hello bash"`

# 变量

- 变量赋值

```shell
a=123       # 变量=值，"="两边不能有空格！！
b=4+5       # b 的值是字符串 4+5，而不是运算结果 9 ！！！
let a=10+20 # 非交互方式：通过 let 命令进行赋值，可以将计算结果赋值给变量，计算的性能很低
# let 还可以直接将数字常量赋值给变量，0 开头代表数字常量为八进制，0x 代表十六进制
read a      # 交互方式：read 命令通过键盘向 a 赋值
l=ls        # 把命令赋值给变量
letc=$(ls -l /etc) # 把命令运行的值赋值给变量，也可以写成 cmd1=`ls -l /etc`
# 变量值有空格等特殊字符，可以包含在 "" 或 '' 中，如：a="I'm zzk"
```

`read [-pt] 变量名`：读取来自键盘输入的变量。

- `-p`：后面可以接提示符
- `-t`：后面可以接等待用户输入的时间，单位为秒

```shell
read -p "请输入你的名字:" -t 30 username
```

- 变量的引用

```shell
${变量名}  # 引用变量
echo ${变量名}  # 查看变量值
```

- 变量的作用范围

定义好的变量，默认仅针对当前的终端（即当前的 shell），对其父/子进程、平行的进程都是不生效的

```shell
a=1  # 当前 shell 下定义 a
bash # 开启一个新的 bash，子 shell
echo $a # 不存在变量 a
```

所以 `bash file.sh`、`sh file.sh`、`./file.sh` 执行脚本时，脚本中定义的变量对当前 shell 无效，，如果想要脚本中定义的变量对当前终端也生效，需采用 `source file.sh`、`. file.sh` 执行脚本；

类似的，如果脚本中想要使用当前 shell 定义的变量，也要采用 `source file.sh`、`. file.sh` 的方式执行脚本。

```shell
export a # 导出变量 a，即使使用 bash file.sh 的方式运行脚本，子进程也可以获得父进程定义的变量 a
# export 导出的变量仅对当前终端及其子 shell 生效，对其他终端不生效
unset a  # 删除变量
```

## 环境&预定义&位置变量

环境变量：每个 Shell 打开都可以获得到的变量

| 环境变量名 | 描述                                                        |
| ---------- | ----------------------------------------------------------- |
| HOME       | 用户的家目录。`cd`指令就是取用了该变量                      |
| SHELL      | 当前环境使用的SHELL是哪个程序，Linux预设为 /bin/bash        |
| HISTSIZE   | 可被记录的历史指令的数量                                    |
| MAIL       | 使用`mail`指令在收信时，系统会读取的邮件信箱文件（mailbox） |
| **PATH**   | 执行文件搜寻的路径。目录与目录间用`:`分隔                   |
| LANG       | 语言数据                                                    |
| RANDOM     | 随机数的变量，bash环境下，该变量介于0~32767之间             |

环境变量 `PS1`：命令提示字符，默认值：`PS1='[\u@\h \W]\$ '`

- `\u`：当前账户名称
- `\h`：仅取主机名在第一个小数点前的名字
- `\W`：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
- `\$` ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $

```shell
env | more # 查看所有已有的环境变量
echo ${变量名} # 查看某一单独的环境变量
# 所有环境变量都经过了 export，对其修改后该变量对当前终端及其子 shell 也会生效，但是对其他终端不生效！！
set | more # 查看当前 shell 下所有的变量
```

- 常用的预定义变量（Shell 设计者事先定义好的变量，可以直接在Shell 脚本中使用）
  - `$?`：上一条命令是否执行成功，0 代表成功，非 0 代表执行不成功
  - `$$`：当前进程的 PID，通常用于脚本或脚本运行状态检测
  - `$0`：当前进程名称
- 位置变量（用于向脚本程序传参）
  - `$n`：n 为数字，`$0` 代表脚本文件名，`$0`-`$9` 分别是第一到九个参数，十及以上写`${10}`这样
  - `$*` 代表命令行中所有参数。该命令将所有参数看作一个整体
  - `$@` 也代表命令行中所有参数。不过把每个参数区分对待
  - `$#` 代表命令行中所有参数的个数

```shell
#!/bin/bash
echo $1
# 技巧：变量替换，某个变量赋值为空时，将其替换为下划线
echo ${2-_}   # 有第二个参数，就输出第二个参数，没有第二个参数，就输出下划线！！！
```

- 环境变量配置文件（/etc 下的配置文件针对所有用户，~ 下的针对当前用户特有的配置）
  - /etc/profile  系统及终端启动时的系统环境配置
  - /etc/profile.d/   该目录下是基于不同的 shell 版本或类型时，加载的各自配置
  - ~/.bash_profile
  - ~/.bashrc
  - /etc/bashrc

`su user` 登录时，仅加载后最两个配置文件；

`su - user`登录时，以上一个目录及四个配置文件都会被加载

可以在四个配置文件中加上 `echo 配置文件名`，然后测试不同登录方式加载的文件及顺序。

如果在不同配置文件中定义同名变量，后加载的配置文件中的变量值会覆盖之前的变量值！

修改了以上配置文件后，并不会立刻加载，而是会在重新登录或重新打开 bash 时才加载，可通过 `source 配置文件` 来立刻加载！

## 数组

```shell
IPTS=(10.0.0.1 10.0.0.2 10.0.0.3)   # 定义数组，每个元素使用空格分隔
echo ${IPTS[@]}   # 显示数组所有元素，${IPTS} 仅显示第一个元素
echo ${#IPTS[@]}  # 显示数组元素个数
echo ${IPTS[0]}   # 指定显示数组某个元素，索引 0 代表第一个元素
```

# 符号

- 转义符号：`\`
  - 普通字符转义后具有特殊功能，如 `\n`
  - 特殊字符转义为普通字符，如 `\"`
- 引用符号：
  - 双引号：变量使用中是不完全引用，会对引号中的内容进行解释，如 `echo "$a"` 会显示 a 的值
  - 单引号：变量使用中是完全引用，不会对引号中的内容进行解释，如`echo '$a'`会显示 $a
  - 反引号：如果反引号括住命令，会执行命令

```shell
echo `ls -l`  # 输出该命令的执行结果
a=`ls -l`     # 该命令执行结果赋值给变量 a
```

- 运算符
  - 算数运算符：`+  -  *  /  **  %`， `**` 是乘方运算符
  - 比较运算符：`>  <  =`
  - 逻辑运算符：`&&  ||  !`  与或非，其中 `&&`、`||` 具有短路功能
  - 自增自减运算符：`++  --`
  - 可以使用 expr 命令进行运算，仅支持整数运算，不支持浮点数

```shell
TEMP=`expr 2 + 3`  # 注意：+ 这样的运算符两边必须有空格！
RESULT=`expr $TEMP \* 4`
echo "result=$RESULT"   #20
```

- `(( ))` 是 let 命令的简写

```shell
(( RESULT=(3+2)*4 ))
echo "result=$RESULT"  #20
(( ! 5 > 4 ))
echo $?  # 1  非零
```



## 特殊符号

- 圆括号`(`
  - 创建数组，见数组部分
  - `$()` 可以将命令执行结果赋值给变量，将变量部分
  - 创建一个子 shell 然后执行括号中的命令，然后结束子 shell

```shell
( abc=123 )  # 创建一个子 shell，然后在子 shell 中为变量赋值
echo $abc  # 因为变量 abc 是在子 shell 中的，所以当前 shell 看不到值
```

- 方括号 `[`

```shell
# 方括号 [] 是 test 命令的简写，见测试部分
[ 5 -gt 4 ]  # 测试 5 是否大于 4
echo $?  # 输出上一条命令执行的结果，这里输出 0，代表测试结果为真
[[ 5 < 4 ]]  # [] 的扩展写法，支持 && || < >，如果用 [] 的话结果不准确
echo $?  # 1
```

- 花括号
  - 表示范围，常用于 for 循环
  - 文件操作中的一些快捷操作

```shell
echo {0..9}  # 0 1 2 3 4 5 6 7 8 9  注意中间是两个点
mkdir {1..9}  # 生成 9 个目录，目录名分别为 1、2、...9
touch /tmp/{1..9}.txt # 在 tmp 下创建 9 个以 .txt 为扩展名的文件
# cp -v /etc/passwd /etc/passwd.bak 的简写
# 其中逗号用于分隔，代表前面是空的无扩展名，后面带扩展名
cp -v /etc/passwd{,.bak}   
```

- 其他

```shell
# 分号; 分隔命令，第一条命令执行完成后再执行第二条
ifdown eth0 ; ifup eth0
# 冒号:  代表空指令什么也不做，常用于死循环中作为占位符
# ~
cd ~ # 返回家目录
cd - # 返回上一次访问的目录
# ,  用于分隔目录，见上面花括号的示例
# * 通配符(占多位)
# ?  条件测试或通配符(仅占一位)
# & 后台运行
# 空格
echo {0..9} # 0 1 2 3 4 5 6 7 8 9
echo { 0..9 }  # { 0..9 }
```

# 流程控制

for、while、util 循环中可以使用 break、continue。

- 退出当前 shell 或终端：`exit`
  - 如果脚本中加了该指令，该指令会读取其上一条指令是否执行成功，执行成功返回 0，失败返回非 0
  - 可以指定上一条指令的返回值，`exit 10` 则无论成功与否都返回 10 给 shell

```shell
#!/bin/bash
pwd
exit 10
```

## 判断与测试

- 测试命令 `test` 用于检查文件或比较值
  - 可简写为 `[]` 符号
  - `[]` 还有扩展写法 `[[ ]]`，支持 `&&  ||  <  >`

常用的判断条件

  - 两个整数的比较：

| 符号 |     ==     | -lt  |   -le    | -eq  | -gt  |   -ge    |  -ne   |
| :--: | :--------: | :--: | :------: | :--: | :--: | :------: | :----: |
| 含义 | 字符串比较 | 小于 | 小于等于 | 等于 | 大于 | 大于等于 | 不等于 |

  - 按照文件权限进行判断：

| 符号 |     -r     |     -w     |      -x      |
| :--: | :--------: | :--------: | :----------: |
| 含义 | 有读的权限 | 有写的权限 | 有执行的权限 |

  - 按照文件类型进行判断：

| 符号 |             -f             |    -e    |          -d          |
| :--: | :------------------------: | :------: | :------------------: |
| 含义 | 文件存在，且是一个常规文件 | 文件存在 | 文件存在且是一个目录 |

``` shell
# man test  查看如何使用
test -f /etc/passwd  # 判断该文件是否存在
[ -d /etc/ ]         # 判断是否为目录
[ 5 -gt 4 ]          # 判断 5 是否大于 4
[[ 5 < 4]]           # 判断 5 是否小于 4，这里如果用 [] 的话，结果不准确
# 比较字符串时建议加上双引号，避免字符串中特殊字符的影响
[ string1 = string2 ]  # 比较两个字符串(不用加引号)是否相等，可区分大小写
```



## if

两种语法：

```sh
if [ 测试条件 ]; then
	# 条件判断成立，todo
else  # else及下面的程序 可以没有
	# 条件判断不成立，todo
fi # 结束if
```

```sh
if [ 测试条件1 ]; then
	# todo
elif [ 测试条件2 ]; then
	# todo
else 
	# todo
fi
```

示例（这里省略了 shell 脚本的声明）：

```shell
# 判断当前用户
if [ $UID = 0]; then  # 测试条件也可以写成 [ $USER = root]
	echo "root user"
else 
	echo $USER
fi

# if 后面也可以跟命令，用于判断该命令是否执行成功
if pwd; then
	echo "pwd running"
fi

# if 的嵌套
if [ $UID = 0 ]; then
	echo "script is running"
	if [ -x /tmp/10.sh ]; then
		./tmp/10.sh
	fi
else
	echo "switch user root"
fi
```



## case 分支

语法：

```shell
case "$变量" in
	"值1"|"值2")  
	# todo cmd1
	;;
	"值3")
	# todo cmd2
	;;
	*)	# * 代表其他，即不满足以上情况时
	# todo other
	;;
esac
```

示例：

```shell
#!/bin/bash
case $1 in
	"start"|"START") # 如果第一个参数为 start 或 START
	echo "$0 starting..."
	;;
	"stop")
	echo "$0 stop..."
	;;
	"restart"|"reload")
	echo "$0 restart..."
	;;
	*)
	echo "Usage: $0 {start|stop|restart|reload}"
	;;
esac
```

## for

语法：

```sh
# 列表中包含多个变量，变量间使用空格分隔
# 列表可以使用 {} 符号生成，也可以使用命令来生成！
# 对文本处理，要使用文本查看命令取出文本内容
	# 默认逐行处理，如果文本出现空格会被当做多行处理
for 变量 in 列表
do
	# todo
done
```

```sh
# 不常用，一般仅在重复多次执行命令时使用
for ((初始值;循环控制条件;变量变化))
do
	# todo
done
```

示例（这里省略了 shell 脚本的声明）：

```shell
# 创建 9 个文件，文件名依次为 file1、file2、... file9
for i in {1..9}
do
	touch "file$i"
done

# 批量修改文件扩展名，将扩展名为 mp3 的文件扩展名修改为 mp4
# 取出文件名（去除扩展名）：basename 文件名 扩展名
for filename in `ls *.mp3`
do
	mv $filename $(basename $filename .mp3).mp4
done

# 执行 /etc/profile.d/ 下所有 .sh 的文件
for sc_name in /etc/profile.d/*.sh
do
	if [ -x $sc_name ]; then
		. $sc_name
	fi
done
```

## while&util

语法：

```shell
# while：只要满足条件就循环
# 可以配合 shift 功能（参数左移），间后面处理位置参数的示例
# 比如执行 a.sh a b c d  遇到 shift 时删除第一个参数，此时 b 就变成了第一个参数
while [ 条件判断 ]  # 如果要写死循环，可以写作：while ；
do 
	# todo
done

# util：当满足条件时终止循环
util [ 条件判断 ]  # util [ 5 -lt 4 ]    就是一个死循环
do
	# todo
done
```

示例：

```shell
while [ $a -lt 10 ]
do
	((a++))
	echo $a
done
```

## 循环处理位置参数

```shell
#!/bin/bash
# for 和 while 循环分别遍历脚本的所有命令行参数，如果参数为 help，则输出 help help
for pos in $*       # $* 获取脚本所有参数
do
	if [ "$pos" = "help" ]; then
		echo $pos $pos
	fi
done

while [ $# -ge 1 ]   # 参数个数大于等于 1
do
	if [ "$1" = "help" ]; then
		echo $1 $1
	fi
	# 执行 a.sh a b c d  遇到 shift 时删除第一个参数，此时 b 就变成了第一个参数
	shift # 参数左移
done
```

#  函数

## 系统函数

- 系统的自建函数库在 /etc/init.d/functions 文件中，脚本中可直接引用
- 可以使用 `source 函数脚本文件` 将其导入当前的 shell 运行环境！！！

```shell
source /etc/init.d/functions
echo_success  # 会输出绿色的 OK 或 确定 字样，如果不导入的话，会提示找不到命令
```

## 自定义函数

- Shell script 的执行方式是由上而下，由左而右，因此函数的设定一定要在程序最前面！

- function 也有内建变量，函数名称为`$0`，后续接的变量也是以`$1`、`$2`...来取代

- 可以使用 `local 变量名` **声明函数内的局部变量**！

- 语法：

  ```sh
  function funname(){ # 关键字 function 可以省略
      Action
      [return int;]
  }
  ```

- 调用：直接写函数名 `funname 传入的参数`

示例：

```sh
#!/bin/bash
checkpid(){
	local i  # 使用局部变量，防止修改函数外的 i 变量
	for i in $*; do
		# 这里通过逻辑运算完成 if then return 的效果
		# [] 成功，才会执行 return 0 的操作
		# 如果 /proc/ 下有和 pid 同名的目录就说明该 pid 是有效的
		[ -d "/proc/$i" ] && return 0
	done
	return 1
}
```

```shell
# 一定要使用 source file.sh 或 . file.sh 的方式运行脚本
source file.sh
checkpid 1 2
echo $?  # 0
checkpid 10000
echo $?  # 1
```

# 捕获信号

可以在备份脚本中捕获信号，避免脚本被 Ctrl + C 或 `kill` 的方式结束掉。

- `kill` 默认发送 15 号信号给应用程序
- Ctrl + C 发送 2 号信号
- 9 号信号不可阻塞，所以无法使用 `trap` 捕获 9 号信号

```shell
#!/bin/bash
# trap 捕获信号：这里捕获到 15 号信号后，执行引号中的内容
trap "echo sig 15" 15
trap "echo sig 2" 2
# 显示当前进程号
echo $$
# 死循环，防止还未捕获到信号进程就退出
while :
do
	:
done
```

```shell
chmod u+x file.sh
./file.sh  # 输出当前进程号为 8773
# 由于脚本也捕获 2 号信号，所以在当前终端下 Ctrl + C 不会终止程序，而是输出 sig 2
# 重新打开另一个终端，使用 kill 发送 15 号信号给进程 8773
kill -15 8773  # kill 默认发送 15 号信号，故这里的 -15 可以省略
# 脚本捕获到 15 号信号，原终端输出 sig 15
# 由于上面的脚本有死循环，即使捕获到 15 号信号，也不会终止进程
# 在另一个终端输入以下内容终止进程
kill -9 8773 
```

# 任务调度

任务调度是指系统在某个时间执行的特定的命令或程序。

## 一次性计划任务

- 一次性计划任务 `at`
  - `atq` 查看未被执行的一次性计划任务
  - 任务如果使用到外键命令，记得加上完整路径
  - **无终端，无法进行标准输出，所以输出时最好重定向到文件**

```shell
at 09:00   # 指定任务的运行时间
echo "hello at" > /tmp/hello.txt
Ctrl + D # 提交任务
# 查看未被执行的一次性计划任务
atq 
```

## 周期性计划任务！

- 系统工作，有些重要的工作必须周而复始地执行，如病毒扫描等；
- 个别用户工作：个别用户可能希望执行某些程序，如对 mysql 数据库的备份

- `crontab [选项]`
  - `-e` 编辑 crontab 定时任务，会打开一个类似 vi 的编辑界面
    - 每个用户有一个自己的周期性计划任务，分别保存在 /var/spool/cron/ 下
  - `-l` 查询现有的 crontab 任务
  - `-r` 终止任务调度，删除当前用户所有者的 crontab 任务
- `service crond restart` 重启任务调度

### Cron 表达式

查看任务调度文件 /etc/crontab 可以看到语法：`* * * * * 待执行的命令或脚本`，脚本需要有执行权限

五个占位符：

| 占位符    | 含义         | 范围                                   |
| --------- | ------------ | -------------------------------------- |
| 第一个 \* | minute       | 0 - 59                                 |
| 第二个 \* | hour         | 0 - 23                                 |
| 第三个 \* | day of month | 1 - 31                                 |
| 第四个 \* | month        | 1 - 12                                 |
| 第五个 \* | day of week  | 0 - 6（0 都代表星期日，也可用 7 表示） |

每个占位符可以使用的特殊符号：

| 符号 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| \*   | 匹配所有值，在分钟域就表示每分钟                             |
| ，   | 指定可选值。如`0 8,12 * * *`代表在每天的 8 点 0 分、12 点 0 分都执行 |
| -    | 指定一个范围。如`0 5 * * 1-6`代表在周一到周六的 5 点 0 分执行 |
| \*/n | 指定增量。如："_/10 _ \* \* \*"代表每 10 分钟就执行一次      |

示例：

| 命令           | 含义                                      |
| -------------- | ----------------------------------------- |
| `45 22 * * *`  | 在 22 点 45 分执行                        |
| `0 17 * * 1`   | 每周一的 17 点 0 分执行                   |
| `0 5 1,15 * *` | 每月 1 号和 15 号的凌晨 5 点 0 分执行一次 |
| `40 4 * * 1-5` | 每周一到周五的凌晨 4 点 40 分执行         |
| `*/10 4 * * *` | 每天的凌晨 4 点开始，每隔 10 分钟执行一次 |
| `0 0 1,15 * 1` | 每月 1、15 号，每周一的 0 点 0 分执行一次 |

```shell
crontab -e   # 配置计划任务，会打开一个类似 vi 的编辑界面
# 输入计划任务，这里每分钟将时间追加写入一个文件中，建议命令和文件写全路径
# 编辑完成后，保存退出即可
* * * * * /usr/bin/date >> /tmp/date.txt
# /var/log/ 下会有一个 cron 的日志，可以使用 tail -f cron 查看日志判断任务是否执行
```

# 追踪与debug

- `sh [选项] hello.sh`
  - `-n`：不执行脚本，仅查询语法的问题
  - `-v`：在执行脚本前，先将脚本的内容输出在屏幕上
  - `-x`：将用到的脚本内容显示在屏幕上！！！！
