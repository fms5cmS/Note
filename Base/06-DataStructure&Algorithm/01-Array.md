数组是一种**线性表**数据结构，用一组**连续的内存空间**来存储一组具有**相同类型的数据**。

从数组的内存模型看，下标更确切地说是 偏移（offset），`a[i]` 表示相对 `a[0]` 偏移 i 个数据类型的位置。

业务开发直接使用容器就足够了，省时省力。尽管会损耗一小部分性能，却完全不会影响到系统整体的性能。但如果做一些非常底层的开发，如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

# 特性

- 随机访问

由于**连续的内存空间**和**相同类型**这两个限制，所以数组具有一个特性：**随机访问**！！数组可以通过寻址公式找到数组中某个元素的地址，寻址公式：

![](../../images/address.png)

如：一个 `int[] a = new int[10]` 的数组，假设内存块的首地址为 1000，则数组中第 3 个元素的地址就是 1000 + 4 \* 3 = 1012，在 Java 中 `int` 型的数据占了 4 字节的内存。

注意：数组适合查找，但查找的时间复杂度并不为 $O(1)$，即使是排序后的数组，使用二分查找的时间复杂度也有 $O(logn)$，所以应说**数组支持随机访问，根据下标随机访问的时间复杂度为 $O(1)$**。

---

- 低效的插入操作

假设数组长度为 n，以下三种插入情况：

1. 在数组的第 k 个位置插入元素，要将 k 到 n 的所有元素都后移一位；
2. 在数组的开头插入元素，时间复杂度为 $O(n)$，因为所有元素都需要向后移动一位；
3. 在数组的末尾插入元素，时间复杂度为 $O(1)$。

由于每个位置插入元素的概率是一样的 $1/n$，故平均时间复杂度：$(1+2+...+n)/n=O(n)$。

如果**数组有序**：那么在某个位置插入元素，就必须按上面那样的方法来移动元素；

如果**数组无序**，仅用于存储数据：要在数组第 k 个位置插入元素，为了避免大规模数据搬移，可以直接**将第 k 个位置的数据放到数组的末尾，再把新的元素放到第 k 个位置**。

利用以上的技巧，在特定场景下，在第 k 个位置插入元素的时间复杂度就成为了 $O(1)$。

---

- 低效的删除操作

与插入操作类似，删除第 k 个位置的元素时，为了内存的连续性，也需要搬移数据。

1. 删除数组开头的元素，时间复杂度为 $O(n)$，因为所有元素都需要向前移动一位；
2. 删除数组末尾的元素，时间复杂度为 $O(1)$。

在某些特殊场景下，并不一定追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率可以提高很多。

如，删除数组中存放的多个数据，每次删除操作仅记录那个位置的元素已经被删除，只有当数组没有更多空间存储数据时，再触发一次真正的删除操作，这样可以减少数据的搬移。这就是标记清除算法的思想。

---

- 要小心数组下标越界问题！

# 声明数组

Java 中声明数组：

```java
int[] array0 = new int[5];  //一维数组推荐这么声明
int array1[] = {4,5,8,23,54};  //声明的同时初始化
int array2[] = new int[]{4,5,8,23,54}; //声明的同时初始化
int[] array3[] = {{2,3,1},{4,90}};  //这么声明二维数组也成立
int[][] array4 = new int[3][]; //第一个中括号必须有值，代表在该二维数组中有多少个一维数组。
```

Go 中：

```go
var arr1 [5]int // 每个元素会被初始化为元素类型的零值，即 [0 0 0 0 0]
arr2 := [3]int{1, 2, 3}
//长度根据初始化值得个数计算
arr3 := [...]bool{true, false, false}
var grid [2][2]int = {{1,2},{3,4}}
//指定索引来初始化，未指定初始值的元素用零值初始化(0 处的元素值为 string 的零值 "")
a := [...]string{1: "no error", 2: "Eio", 3: "invalid argument"}
```
