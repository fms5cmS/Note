# 哈希算法

**哈希算法**用于将任意长度的二进制值串映射为固定长度的二进制值串(即哈希值)。

哈希算法有以下几点要求：

- 从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法)；
- 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
- 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
- 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

哈希算法常用的有七个应用，如下。

## 安全加密

常用于加密的哈希算法是 MD5(MD5 Message-Digest Algorithm，MD5 消息摘要算法)、SHA(Secure Hash Algorithm，安全散列算法)，其他的还有 DES(Data Encryption Standard，数据加密标准)、AES(Advanced Encryption Standard，高级加密标准)等。

用于加密的哈希算法最重要的要求：很难根据哈希值反向推导出原始数据、散列冲突的概率要很小。

以 MD5 为例，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 $2^128$ 个数据，所以必然会存在哈希值冲突，但是因为哈希值的范围很大，冲突的概率极低，相对来说还是很难破解的。一般而言，哈希值越长的哈希算法，散列冲突的概率越低。

没有绝对安全的加密算法，所有的安全措施，只是增加攻击的成本而已。

![为什么使用 MD5 存储密码非常危险](https://mp.weixin.qq.com/s/8AH668faMYVXnvsSjrHY3A)


## 唯一标识

Q：在海量的图库中搜索某张图片是否存在时，该如何搜索呢？

我们无法单纯地使用图片的元信息(如名称)来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。

任何文件在计算中都可以表示成二进制码串，很笨的一个方法就是拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对，但是每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的串，比对起来会非常耗时。

可以给每一个图片取一个唯一标识，或者说信息摘要！比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法(如 MD5)得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。

还想继续提高效率的话，可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。要查看某个图片是不是在图库中时：

1. 通过哈希算法对这个图片取唯一标识
2. 在散列表中查找是否存在这个唯一标识
   1. 如果不存在，那就说明这个图片不在图库中；
   2. 如果存在，再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样
      1. 如果一样，就说明已经存在；
      2. 如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。


## 数据校验

BT 下载的原理是基于 P2P 传输协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块(如分成 100 块，每块大约 20MB)。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。

而网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能是不完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。现在的问题是，如何来校验文件块的安全、正确、完整呢？

PS：这里仅是一种简单思路，实际要复杂很多。

通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。


## 散列函数

相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。

散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布；

散列函数用的散列算法一般都比较简单，比较追求效率，因为散列函数执行的快慢，也会影响散列表的性能。


## 负载均衡

负载均衡的算法有很多，如轮询、随机、加权轮询等。如何才能实现一个会话粘滞(session sticky)的负载均衡算法呢？也就是同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。

可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。


## 数据分片

针对海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。

- 示例一：统计“搜索关键词”出现的次数

Q：假如有 1T 的日志文件，里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？

难点：搜索日志很大，无法放到一台机器的内存中；如果只用一台机器来处理这么巨大的数据，处理时间会很长。

针对这两个难点，可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体如下：

为了提高处理的速度，用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。

这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。

- 示例二：快速判断图片是否在图库中

之前在唯一标识部分简单介绍过，假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。

同样对数据分片，然后采用多机处理。准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。

判断图片是否在图库时，先通过同样的哈希算法计算图片的唯一标识，然后和机器数取模，得到的结果 k 就说明要去编号 k 的机器构建的散列表中查找。

Q：这 1 亿张图片构建散列表大约需要多少台机器？

散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 16B(即128bit)。文件路径长度的上限是 256B，我们可以假设平均长度是 128B。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8B。所以，散列表中每个数据单元就占用 152B(这里只是估算，并不准确)。

假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万(2GB*0.75/152)张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。


## 分布式存储

为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，如分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是就需要将数据分布在多台机器上。那么，如何决定将哪个数据放到哪个机器上呢？

可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。

但是，当数据增多需要扩容时，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生[雪崩效应](https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94)，压垮数据库。可以使用[一致性哈希算法](../../advance/Cache/README.md)