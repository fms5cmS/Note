# I/O模型

所谓 I/O 模型，就是我们处理 I/O 的方式。一般而言，单次 I/O 请求会分为令各阶段，每个阶段对 I/O 的处理方式不同：

- 等待资源阶段(如等待网络传输数据可用)有两种处理方式：
  - 阻塞，指的是在数据不可用时 I/O 请求一直阻塞，直到数据返回；
  - 非阻塞，指的是数据不可用时 I/O 请求立即返回，直到被通知资源可用为止。
- 使用资源阶段(如从网络上接收到数据并拷贝到应用程序的缓冲区中)有两种处理方式：
  - 同步处理，指的是 I/O 请求在读取或者写入数据时会阻塞，直到读取或者写入数据完成；
  - 异步处理，指的是 I/O 请求在读取或者写入数据时立即返回，当操作系统处理完成 I/O 请求并且将数据拷贝到用户提供的缓冲区后，再通知应用 I/O 请求执行完成。

将两个阶段的四种处理方式组合，再做一些补充，就得到了常见的五种 I/O 模型：

- 同步阻塞 I/O；
- 同步非阻塞 I/O；
- 同步多路 I/O 复用；
- 信号驱动 I/O；
- 异步 I/O

假设 I/O 过程是烧水倒水的过程，等待资源(烧水的过程)，使用资源(倒水的过程)：

- 站在灶台边上一直等着(等待资源)水烧开，然后倒水(使用资源)，就是同步阻塞 I/O；
- 在烧水的时候躺在沙发上看会儿电视(不再时时刻刻等待资源)，但是还是要时不时地去看看水开了没有，一旦水开了，马上去倒水(使用资源)，那么这就是同步非阻塞 I/O；
- 如果需要同时烧好多壶水，那就在看电视的间隙去看看哪壶水开了(等待多个资源)，哪一壶开了就先倒哪一壶，这样就加快了烧水的速度，这就是同步多路 I/O 复用；
- 给水壶加一个报警器(信号)，只要水开了就马上去倒水，这就是信号驱动 I/O；
- 发明了一个智能水壶，在水烧好后自动就可以把水倒好，这就是异步 I/O。

最被广泛使用的是多路 I/O 复用，Linux 系统中的 select、epoll 等系统调用都是支持多路 I/O 复用模型的，Java 中的高性能网络框架 Netty 默认也是使用这种模型。