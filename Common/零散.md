# 位运算

一个常见的等式 ：`-n = ~n+1`！！所以`~1=-2`

优先级：`~`>`&`>`^`>`|`。以下操作是**对实际存储地二进制位进行操作的**

- **按位取反**： `~`

- **按位与**：`&`，对应的两个对应两个二进位均为 1 时才为 1 。用补码计算！！！

  - 可以对某位进行清零操作（需要清零的位与 0 进行 & 运算） ；
  - 可以提取某些位（需要提取的位与 1 进行 & 运算） 。

- **按位或**：`|`，如：`0 | 1 = 1`。可以对某些位进行置一操作。

- **按位异或**：`^`，对应两个二进位相同时，结果为 0，否则为 1 。如：`0 ^ 1 = 1`。

  - 与 0 异或，可以保留原值；

  - 将特定位翻转：即 1 变 0，0 变 1 ；

  - 不用临时变量而交换两个值。

    ```java
    案例：a=6，b=5 交换a、b的值
    第一步：b = a ^ b = 011
    第二步：a = a ^ b = 110 = 6
    第三部：b = a ^ b = 101 = 5
    ```

- **左移**：`a<<n`，将 a 的二进位全部左移 n 位。

  - 高位丢弃，低位补零。
  - 对于无符号数，左移 n 位相当于乘 2 的 n 次方。

- **右移**：`a>>n`，将 a 的二进位全部右移 n 位。

  - 对于无符号数，左端空位补零；
  - 对于有符号数，左端空位全部补符号位；
  - 右移 n 位相当于 除以 2 的 n 次方。

- **无符号右移**：`>>>`无符号右移，高位补 0 。Go 中没有。

- 注意：不同长度的数据进行位运算：

  - 1.将操作数右端对齐；
  - 2.将位数短的往高位补充（无符号和正整数左侧用 0 补全，负数用 1 补全）。

---

**一个偶数和数字 1 按位与的结果一定是 0 ；而奇数和数字 1 按位与的结果一定是 1。** 可以通过这种方式来判断奇偶。

```Java
System.out.println(5 & 1);  // 1
System.out.println(10 & 1); // 0

if( number & 1 == 0){
  // TODO number 为偶数情况下执行的操作
}else{
  // TODO number 为奇数情况下执行的操作
}
```

更多的位运算技巧：[优秀程序员不得不知道的 20 个位运算技巧](https://blog.csdn.net/zmazon/article/details/8262185)

# Unicode 与字符编码

在计算机系统内部，抽象的字符会被编码为整数，这些整数的范围被称为代码空间。在代码空间内，每一个特定的整数都被称为一个代码点。一个代码点总是可以被看成一个被编码的字符。

Unicode 编码规范通常使用十六进制表示 Unicode 代码点的整数值，并使用 “U+” 作为前缀，如英文字母字符 “a” 的 Unicode 代码点是 U+0061。

Unicode 编码规范提供了三种编码格式：UTF-8、UTF-16、UTF-32。其中 UTF 代表的是字符和字节序列之间的转换方式。“-” 右边的整数则表示以多少个 bit 作为一个编码单元。

UTF-8 是一种可变宽的编码方案。会用一个或多个字节的二进制数表示某个字符，最多使用四个字节。如英文字符仅用一个字节的二进制数即可，而对于一个中文字符，则需要使用三个字节。

- ASCII 码中，7 位二进制数表示一个字符，最高位为 0。可表示常用字符 128 个，编码从 0 到 127。
  - 普通字符：
    - 10 个数字：48——57；
    - A——Z：65——90；
    - a——z：97——122
  - 控制字符：0——31 及 127
    - 如：CR（回车）、LF（换行）、FF（换页）、DEL（删除）、BS（退格）
- GBK 编码中，中文占 2 个字节，英文占 1 个字节；UTF-8 编码中，中文占 3 个字节，英文占 1 个字节；Java 使用双字节编码 UTF-16，中文和英文都占 2 个字节。
- 编码与解码：
  - 字符———— 编码字符集————>二进制
  - 二进制————解码字符集————>字符
- 乱码产生原因：
  - 编码和解码的字符集不统一
  - 字符缺少，长度丢失

# 换行符

- Windows/DOS 系统：采用 CR/LF 表示下一行；
- Unix/Linux 系统：采用 LF 表示下一行；
- Mac OS 系统：采用 CR 表示下一行；
- Mac OS X 系统：采用 LF 表示下一行（ Mac OS X 已经改成和 Unix/Linx 一样使用 LF ）。

# 版本号

- alpha 版：内部测试版。α 是希腊字母的第一个，表示最早的版本，bug 很多。主要是给开发和测试人员找 bug 用的。
- beta 版：公开测试版。 主要是给“部落”用户和忠实用户测试用的。bug 依然很多，但比 Alpha 版要稳定。这个阶段的版本还会不断增加新功能，如果你是发烧友，可以下载这个版本。
- rc 版：候选版本（Release Candidate）。该版本不再增加新的功能。类似于最终发行版之前的预览版（发行的候选版本）。此版本的发布，预示着最终发行版即将到来。作为普通用户，如果很着急，也可以下载 rc 版。
- stable 版：稳定版。在开源软件中，都有 stable 版本，这个是开源软件的最终发行版，用户可以放心大胆地使用。

- 开发版本：Snapshot
- 发布版本：Release

# 语义化版本号(SemVer)

[Semantic Versioning](https://semver.org/)

版本号的格式为：“主版本号.次版本号.修订号”。如 v1.2.3，其中 1 代表主版本号，2 代表次版本号，3 代表修订号。

版本号的递增规则如下：

- 主版本号：当你做了不兼容的 API 修改。
- 次版本号：当你做了向下兼容的功能性新增。
- 修订号：当你做了向下兼容的问题修正

语义化版本的控制： v1.3 和 v1.4 版本变更，都属于次版本号的变更，而在语义化版本的约束下，v1.4 必须是要向下兼容 v1.3 版本。

在 Go Modules 中还支持先行版本，如：v1.2.3-pre
