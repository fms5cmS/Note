# 位运算

一个常见的等式 ：`-n = ~n+1`！！所以`~1=-2`

优先级：`~`>`&`>`^`>`|`。以下操作是**对实际存储地二进制位进行操作的**

- **按位取反**： `~`

- **按位与**：`&`，对应的两个对应两个二进位均为 1 时才为 1 。用补码计算！！！

  - 可以对某位进行清零操作（需要清零的位与 0 进行 & 运算） ；
  - 可以提取某些位（需要提取的位与 1 进行 & 运算） 。

- **按位或**：`|`，如：`0 | 1 = 1`。可以对某些位进行置一操作。

- **按位异或**：`^`，对应两个二进位相同时，结果为 0，否则为 1 。如：`0 ^ 1 = 1`。

  - 与 0 异或，可以保留原值；

  - 将特定位翻转：即 1 变 0，0 变 1 ；

  - 不用临时变量而交换两个值。

    ```java
    案例：a=6，b=5 交换a、b的值
    第一步：b = a ^ b = 011
    第二步：a = a ^ b = 110 = 6
    第三部：b = a ^ b = 101 = 5
    ```

- **左移**：`a<<n`，将 a 的二进位全部左移 n 位。

  - 高位丢弃，低位补零。
  - 对于无符号数，左移 n 位相当于乘 2 的 n 次方。

- **右移**：`a>>n`，将 a 的二进位全部右移 n 位。

  - 对于无符号数，左端空位补零；
  - 对于有符号数，左端空位全部补符号位；
  - 右移 n 位相当于 除以 2 的 n 次方。

- **无符号右移**：`>>>`无符号右移，高位补 0 。Go 中没有。

- 注意：不同长度的数据进行位运算：

  - 1.将操作数右端对齐；
  - 2.将位数短的往高位补充（无符号和正整数左侧用 0 补全，负数用 1 补全）。

---

**一个偶数和数字 1 按位与的结果一定是 0 ；而奇数和数字 1 按位与的结果一定是 1。** 可以通过这种方式来判断奇偶。

```Java
System.out.println(5 & 1);  // 1
System.out.println(10 & 1); // 0

if( number & 1 == 0){
  // TODO number 为偶数情况下执行的操作
}else{
  // TODO number 为奇数情况下执行的操作
}
```

更多的位运算技巧：[优秀程序员不得不知道的 20 个位运算技巧](https://blog.csdn.net/zmazon/article/details/8262185)

# Unicode 与字符编码

在计算机系统内部，抽象的字符会被编码为整数，这些整数的范围被称为代码空间。在代码空间内，每一个特定的整数都被称为一个代码点。一个代码点总是可以被看成一个被编码的字符。

Unicode 编码规范通常使用十六进制表示 Unicode 代码点的整数值，并使用 “U+” 作为前缀，如英文字母字符 “a” 的 Unicode 代码点是 U+0061。

Unicode 编码规范提供了三种编码格式：UTF-8、UTF-16、UTF-32。其中 UTF 代表的是字符和字节序列之间的转换方式。“-” 右边的整数则表示以多少个 bit 作为一个编码单元。

UTF-8 是一种可变宽的编码方案。会用一个或多个字节的二进制数表示某个字符，最多使用四个字节。如英文字符仅用一个字节的二进制数即可，而对于一个中文字符，则需要使用三个字节。

- ASCII 码中，7 位二进制数表示一个字符，最高位为 0。可表示常用字符 128 个，编码从 0 到 127。
  - 普通字符：
    - 10 个数字：48——57；
    - A——Z：65——90；
    - a——z：97——122
  - 控制字符：0——31 及 127
    - 如：CR（回车）、LF（换行）、FF（换页）、DEL（删除）、BS（退格）
- GBK 编码中，中文占 2 个字节，英文占 1 个字节；UTF-8 编码中，中文占 3 个字节，英文占 1 个字节；Java 使用双字节编码 UTF-16be，中文和英文都占 2 个字节。
- 编码与解码：
  - 字符———— 编码字符集————>二进制
  - 二进制————解码字符集————>字符
- 乱码产生原因：
  - 编码和解码的字符集不统一
  - 字符缺少，长度丢失

# 零散

- **同步与异步**

**同步：**同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。

**异步：**异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。

---

- **阻塞和非阻塞**

**阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。

**非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

---

- 绑定

绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对 java 来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定.。

**前期绑定**：在编译过程中就已经知道调用的方法具体是哪个类中的方法。

在 Java 中只有 `static` 方法和 `final` 方法是静态绑定的。注意：构造器被隐式声明为 `static` 方法、而 `private` 方法也属于 `final` 方法。

**后期绑定**：只有在程序运行时才知道调用的具体是那个类的方法。而编译器只能确保被调用方法的存在，并对调用参数和返回值进行类型检查，但并不知道被执行的具体代码。

在使用多态过程中，假设父类定义了一个`move()`方法，而其多个子类根据自己的实际情况对该方法进行了覆盖（override），那么，当使用父类型来接收一个子类实例（即多态）后，此时调用`move()`方法，编译器执行的是父类还是子类的方法呢？答案当然是执行该实例实际的子类类型的`move()`方法。这就是后期绑定的好处了。

# 换行符

- Windows/DOS 系统：采用 CR/LF 表示下一行；
- Unix/Linux 系统：采用 LF 表示下一行；
- Mac OS 系统：采用 CR 表示下一行；
- Mac OS X 系统：采用 LF 表示下一行（ Mac OS X 已经改成和 Unix/Linx 一样使用 LF ）。

# 版本号

- alpha 版：内部测试版。α 是希腊字母的第一个，表示最早的版本，bug 很多。主要是给开发和测试人员找 bug 用的。
- beta 版：公开测试版。 主要是给“部落”用户和忠实用户测试用的。bug 依然很多，但比 Alpha 版要稳定。这个阶段的版本还会不断增加新功能，如果你是发烧友，可以下载这个版本。
- rc 版：候选版本（Release Candidate）。该版本不再增加新的功能。类似于最终发行版之前的预览版（发行的候选版本）。此版本的发布，预示着最终发行版即将到来。作为普通用户，如果很着急，也可以下载 rc 版。
- stable 版：稳定版。在开源软件中，都有 stable 版本，这个是开源软件的最终发行版，用户可以放心大胆地使用。

- 开发版本：Snapshot
- 发布版本：Release

# 语义化版本号(SemVer)

[Semantic Versioning](https://semver.org/)

版本号的格式为：“主版本号.次版本号.修订号”。如 v1.2.3，其中 1 代表主版本号，2 代表次版本号，3 代表修订号。

版本号的递增规则如下：

- 主版本号：当你做了不兼容的 API 修改。
- 次版本号：当你做了向下兼容的功能性新增。
- 修订号：当你做了向下兼容的问题修正

语义化版本的控制： v1.3 和 v1.4 版本变更，都属于次版本号的变更，而在语义化版本的约束下，v1.4 必须是要向下兼容 v1.3 版本。

在 Go Modules 中还支持先行版本，如：v1.2.3-pre
