# Q

Q：对比`Vector`、`ArrayList`、`LinkedList`有何区别。

A：都实现了`List`，因此具体功能类似，如都提供了按照位置进行定位、添加、删除操作，都提供迭代器来遍历内容。但由于具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同：

- `Vector`是线程安全的动态数组，基于对象数组实现，可根据需要自动扩容，扩容后的容量是原本的2倍；

- `ArrayList`不是线程安全的，所以性能要好很多，基于对象数组实现。可根据需要调整容量，扩容后的容量是原本的1.5倍；

- `LinkedList`是基于双向循环链表，不是线程安全的。

`Vector`和`ArrayList`作为动态数组，其内部元素以数组的形式顺序存储，所以非常适合随机访问的场合，除了尾部插入和删除元素，往往性能会相对较差，如果在中间位置插入一个元素，需要移动后续所有元素。

而`LinkedList`进行节点插入、删除都是移动指针，所以效率较高，但是随机访问性能则要比动态数组差。



# 扩展

## Base

`Collection`接口是所有集合的根，子接口主要有三大类集合：

- `List`：有序集合，提供了方便的访问、插入、删除等操作；
- `Set`：不允许重复元素
  - `TreeSet`：支持自然顺序访问，但添加、删除、包含等操作相对低效($O(logN)$时间)；
  - `HashSet`：利用哈希算法，理想情况下，如果哈希散列正常，可以提供常数时间的添加、删除、包含等操作，但不保证有序。在遍历元素时，性能受自身容量影响，所以初始化时，除非必要，不然不要将其容量设置过大；
  - `LinkedHashSet`：内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力(遍历性能之和元素多少有关)，同时也保证了常数时间的添加、删除、包含等操作，这些操作性能略低于`HashSet`，因此需要维护链表的开销。
- `Queue`（`Deque`继承`Queue`）：标准队列结构的实现，除集合的基本功能，还支持类似 FIFO 或 LIFO 等特定行为。



`Collections`工具类中提供了一系列的`synchronized`方法，其实现基本就是将每个基本方法都通过`synchronized`添加基本的同步支持。注意：这些方法创建的线程安全集合，都符合迭代时 fail-fast 行为，当发生意外的并发修改时，尽早抛出 `ConcurrentModificationException`异常，以避免不可预计的行为。



## 排序

Java 提供的默认排序算法：

- 对于原始数据类型，目前使用的是双轴快速排序(`DualPivotQuicksort `)，是一种改进的快速排序算法；
- 对于对象数据类型，目前使用的是`TimSort`，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。

Java 8 引入了并行排序算法(直接使用 parallelSort 方法)，这是这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架，当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。









