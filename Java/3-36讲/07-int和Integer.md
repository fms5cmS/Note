# Q

Q：`int`和`Integer`有什么区别？谈谈`Integer`的值缓存范围。

A：`int`是基本数据类型之一。`Integer`是`int`对应的包装类，有一个`int`类型的字段存储值，并提供了基本操作(数学运算、`int`和字符串间的转换等)。Java 5 中，引入了自动装箱和自动拆箱功能，根据上下文实现`int`和`Integer`的自动转换。

实际中，大部扽数据操作都是集中在有限的、较小的数值范围，因此 JDK 1.5 中增加了静态工厂方法 `valueOf()`，在调用时会利用缓存机制，带来明显的性能改进。缓存范围：-128 到 127 之间。

优先使用基本类型，原则上，建议避免无意中的装、拆箱行为，尤其是在性能敏感的场合。

# 扩展

**当"=="两边的两个操作数据都是包装类型的引用时，比较的是地址；而只要有一个是基本数据类型（表达式，包含算术运算），就会触发自动拆箱，此时比较的是数值。对于包装类型，equals方法不会进行类型转换。** 



## 自动装、拆箱

自动装、拆箱算是一种语法糖，语法糖可以理解为Java 平台会自动进行一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，即生成的字节码是一致的。

自动装箱：底层调用`valueOf(int i)`方法。

自动拆箱：底层调用`xxxValue()`方法 。

自动装箱的执行效率和资源占用在一般性情况下优于直接创建对象（不是绝对的）。 

注意：基本数据类型的数组和包装类的数组不能直接转换。如`Integer[]`和`int[]`不能直接转换！

- 为什么`Double`和`Integer`类型的`valueOf()`方法的实现不同？       
  - 答：因为在一个范围内，整数的个数是有限的，而浮点数却是无限。 



## 缓存机制

JDK1.5以后，Java在五大包装类（`Byte`，`Charactor`，`Short`，`Integer`，`Long`）增加了相应的私有静态成员内部类为相应包装类对象提供缓存机制，而在`Double`、`Float`类中没有缓存机制。 

对于有缓存机制的包装类，缓存机制发生在`valueOf()`中，即仅在自动装箱时才有缓存。

- 包装类的缓存
  - `Boolean`：(全部缓存)
  - `Byte`：(全部缓存)
  - `Character`(<= 127缓存)：`\u0000` 到 `\u007F`
  - `Short`(-128 — 127缓存)
  - `Long`(-128 — 127缓存)
  - `Integer`(-128 — 127缓存)
  - `Float`(没有缓存)
  - `Doulbe`(没有缓存) 



## Integer源码

常量：最大值、最小值、位数等；

各种静态工厂方法，如`valueOf()`；

获取环境变量数值的方法；

各种转换方法，如：转换为二进制、八进制、十六进制的字符串的静态方法、反过来的解析方法等。

`Integer`的缓存范围默认是 -128 到 127，如果需要提高缓存上限值，JVM 提供了参数设置：`-XX:AutoBoxCacheMax=N`。注意：只能改变上限，下限无法修改。

包装类中存储数值的成员变量`value`被声明为`private final`，是不可变类型。原因：假设有如下场景，`Integer`的`getInteger()`用于方便地读取系统属性，我们可以用属性来设置服务器某个服务的端口，如果可以轻易把获取到`Integer`对象改变为其他数值，这会带来产品可靠性方面的严重问题。



## 原始数据类型和引用类型局限性

- 原始数据类型和 Java 泛型不能配合使用；
- 无法高效地表达数据，也不便于表达复杂的数据结构，比如`vector`和`tuple`
  - 原始数据类型数组才内存中是一段连续的内存，而对象数组则不然，Java 的对象都是引用类型，数组存储的是引用，对象往往分散地存储在堆的不同位置。这种设计带来了极大灵活性，但也导致了数据操作的低效，尤其是无法冲扽利用现代 CPU 缓存机制。
  - Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。

