# Q

Q：`String`、`StringBuffer`、`StringBuilder`的区别。

A：

`String`提供了构造和管理字符串的各种基本逻辑，是典型的 Immutable 类，被声明为`final`类，所有属性也是`final`的。由于它的不可变性，类似拼接、裁剪字符串等操作都会产生新的`String`对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。

`StringBuffer`是为解决上面提到的拼接产生太多中间对象的问题而提供的一个类。本质是一个线程安全的可修改字符序列，保证了线程安全，也带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用`StringBuilder`。

`StringBuilder`在能力上和`StringBuffer`没有本质区别，但去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。

- 区别：

  - 可变性：

    - `String`使用`final`字符数组来保存字符串(`private final char value[]`)，故`String`对象不可变；

      - `String`不可变，但是引用可以改变

        ```java
        String str = "Hello";
        str += "World";  //开辟了一块内容为Hello World的内存，然后str由原来的地方指向这里
        ```

    - `StringBuilder`与`StringBuffer`都继承自`AbstractStringBuilder`类，在`AbstractStringBuilder`中是使用字符数组保存字符串`char[]value` 但是没有用`final`关键字修饰，所以这两种对象都是可变的。

  - 线程安全性：

    - `String`中的对象是不可变的，也就可以理解为常量，线程安全；
    - `StringBuffer`对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的；
    - `StringBuilder`并没有对方法进行加同步锁，所以是非线程安全的。

  - 内存位置：

    - `String`是存放在常量池，在编译期已经被确定了；
    - `new String()`不是字符串常量，它有自己的地址空间，存放在堆空间；
    - `StringBuilder`与`StringBuffer`都存放在堆空间。



# 扩展

## 字符串设计

`String`是 Immutable 类的典型实现，原生的保证了基础线程安全，因为我们无法对其内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。

`StringBuffer`的线程安全是通过把各种修改数据的方法加上`synchronized`实现的。

为了实现修改字符序列的目的，`Stringbuffer`和`StringBuilder`底层都是利用可修改的`char`(JDK 9以后是`byte`)数组，二者都继承了`AbstractStringBuilder`，里面包含了基本操作，区别仅在于最终的方法是否加了`synchronized`。

那么，内部数组应该创建成多大呢？太小，拼接的时候可能要重新创建足够大的数组；太大又会浪费空间。目前的实现是：构建时初始字符串加16 (即，如果构建对象时没有输入字符串，初始值就是16)。如果确定拼接会发生非常多次，且大概是可预估的，就可以指定合适的大小，避免多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的数组，还要进行 array copy。



## 字符串使用

在没有线程安全问题的情况下，全部拼接操作都用`StringBuilder`实现吗？通常情况下，没有必要过于担心，可以直接使用`+`来进行字符串拼接操作：

```java
public class StringConcat {
    public static void main(String[] args) {
        String myStr = "aa" + "bb" + "cc" + "dd";
        System.out.println("My String:" + myStr);
    }
}
```

`javap -v StringConcat.class`反编译后，可以看到字符串拼接操作会自动被 javac 转换为`StringBuilder`操作，而在 JDK 9 中则由于 Java 9 为了更加统一字符串操作优化，提供了`StringConcatFactory`作为一个统一的入口。

- 应用场景：
  - 在字符串内容不经常发生变化的业务场景优先使用`String`类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用`String`与`String`之间的`+`操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。
  - 在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用`StringBuffer`，例如XML解析、HTTP参数解析与封装。
  - 在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用`StringBuilder`，例如SQL语句拼装、JSON封装等。



## 字符串缓存

如果能避免创建重复字符串，可以有效降低内存消耗和对象创建开销。

`String`在 Java 6 以后提供了`intern()`方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在创建字符串对象并调用`intern()`方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。

但是！使用 Java 6 这种历史版本时不推荐大量使用`intern()`，因为被缓存的字符串存在于 PermGen 即永久代中，该控件是有限的，也基本不会被 FullGC 之外的 GC 照顾到，使用不当，就会出现OOM。后续版本中，**这个缓存被放在堆中**，极大避免了永久代占满的问题。JDK 8 中永久代被 MetaSpace 替代，且默认缓存大小也在不断扩大。

`intern`是一种显式地排重机制，但每次显式调用都很麻烦，且很难保证效率。在 Oracle JDK 8u20 后退出了一个新特性：G1 GC 下地字符串排重，它是通过将相同数据的字符串指向同一份数据实现的，是 JVM 底层地改变，不需要 Java 类库做修改，但该功能默认关闭，可使用`-XX:+UseStringDeduplication`参数开启，切记指定使用 G1 GC。



## 字符串创建

Java 为避免在一个系统中产生大量`String`对象，引入了字符串常量池。运行机制：

创建一个字符串时，先检查池中是否有值相同的字符串对象，有则不需要创建直接返回从池中查找到的对象引用，没有则创建字符串对象，返回对象引用并将新创建的对象放入池中。

注意：通过`new`来创建的`String`对象是不检查字符串池的，而是直接在堆或栈创建一个新对象，也不会把对象放入池中。

```java
String str1 = "123"; //创建的字符串在字符串常量池中
String str2 = new String("123"); //创建字符串时，首先查看池中是否有相同值的字符串，如果有，则拷贝一份到堆中，然后返回堆中的地址；如果池中没有，则在堆中创建一份，然后返回堆中的地址
```

注意：`String`提供了`inter()`方法。调用该方法时，如果常量池中包括了一个等于此`String`对象的字符串（由`equals()`确定），则返回池中的字符串。否则，将此`String`对象添加到池中，并且返回此池中对象的引用。





## String演化

`String`在历史版本中使用`char[]`来存数据，但 Java 中`char`是两个字节，拉丁语系语言的字符不需要太宽的`char`，这样无差别的实现造成了一定浪费；

Java 6 时，Oracle JDK 提供了压缩字符串的特性，但并不是开源的，且存在一些问题，所以后续版本已移除；

Java 9 中，引入了 Compact Strings 的设计，将数据存储方式改变为`byte[]`加上一个标识编码的 coder，且将相关字符串操作类都进行了修改。





