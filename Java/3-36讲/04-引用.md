# Q

Q：强引用、软引用、弱引用、幻象引用(虚引用)的区别。

A：不同的引用类型，主要体现的是对象不同的可达性(reachable)状态和对垃圾收集的影响。所有引用类型都是抽象类`java.lang.ref.Reference`的子类(提供了`get()`)，强引用不是。

- 强引用（Strong Reference）：引用指向对象，GC 运行时不回收 
  - JVM 内存不足时，JVM 宁愿抛出`OutOfMemoryError`，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
  - 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 `null`，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。
  - 如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为`null`，这样一来的话，JVM在合适的时间就会回收该对象。比如`Vector`类的`clear()`方法中就是通过将引用赋值为`null`来实现清理工作的。
- 软引用（`SoftReference`类）：JVM 认为内存不足时，会试图回收软引用指向的对象
  - JVM 会确保在抛出`OutOfMemoryError`前，清理软引用指向的对象。
  - 软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时不会耗尽内存。如：图片缓存中的图片就是以软引用保存。
- 弱引用（`WeakReference`类）：GC 运行时立即回收（无论内存是否足够）
  - 可以用于构建一种没有特定约束的关系，如：维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重新实例化。也是很多缓存实现的选择。
- 虚引用（`PhantomReference`类）：不能通过它访问对象，任何时候都可能被 GC 回收。调用`get()`永远返回`null`
  - 仅仅提供一种确保被`finalize`后，做某些事的机制，如，常用来做所谓的 Post-Mortem 清理机制。
  - 主要跟踪对象被回收的状态，不能单独使用，必须与引用队列（`ReferenceQueue`）联合使用。 
  - 可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被 GC 回收之前会收到一条系统通知。
  - 当垃圾回收器准备回收一个对象时，如果发现它还有幻象引用，就会把这个幻象引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了幻象引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个幻象引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 



# 扩展

## 可达性级别

- 强可达(Strongly Reachable)：当一个对象有一个或多个线程可以不通过各种引用访问到的情况。
  - 如：船舰一个对象，那么创建它的线程对它就是强可达
- 软可达(Softly Reachable)：只能通过软引用才能访问到对象的状态。
- 弱可达(Weakly Reachable)：无法通过强引用或软引用访问，只能能通过弱引用访问时的状态。
- 幻象可达(Phantom Reachable)：没有强、软、弱引用关联，且 finalize 过了，只有幻象引用指向这个对象。
- 不可达(unreachable)：意味着对象可以被清除了。

除了幻象引用，如果对象还没有被销毁，都可通过`get()`获取原有对象，也就是说，利用软、弱引用，可将访问到的对象重新指向强引用，即认为地改变了对象地可达性状态。

所以，对于软、弱引用之类，GC可能会存在二次确认的问题，以保证处于弱引用状态的对象没有改变为强引用。

如果错误地保持了强引用(如，赋值给了`static`变量)，那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路，如果我们的框架使用到弱引用又怀疑有内存泄漏，就可以从这个角度检查。



## 引用队列

在创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列`ReferenceQueue`，JVM 会在特定时机将引用 enqueue 到队列中，我们可以从队列中获取引用进行相关后续逻辑。

幻象引用必须和引用队列联合使用，`get()`只返回`null`，如果再不指定引用队列，基本就没有意义了。

```java
Object counter = new Object();
ReferenceQueue refQueue = new ReferenceQueue<>();
PhantomReference<Object> p = new PhantomReference<>(counter, refQueue);
counter = null;
System.gc();
//当GC准备回收counter时，如果发现它还有幻象引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
try {
    // Remove 是一个阻塞方法，可以指定 timeout，或者选择一直阻塞
    Reference<Object> ref = refQueue.remove(1000L);
    if (ref != null) {
    	// do something
    }
} catch (InterruptedException e) {
    // Handle it
}
```

软引用可以和一个引用队列（`ReferenceQueue`）联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM 就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用`ReferenceQueue`的`poll()`方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个`null`,否则该方法返回队列中前面的一个Reference对象。

弱引用可以和一个引用队列（`ReferenceQueue`）联合使用，如果弱引用所引用的对象被垃圾回收，JVM 就会把这个弱引用加入到与之关联的引用队列中。





