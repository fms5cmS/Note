# Kafka 集群部署规划

## Kafka 安装到什么 OS 上比较好？

Kafka 由 Scala 语言和 Java 语言编写而成，编译之后的源代码就是普通的“.class”文件。本来部署到哪个操作系统应该都是一样的，但是不同操作系统的差异还是给 Kafka 集群带来了相当大的影响。主要是在以下三个方面上 Linux 更胜一筹：

- I/O 模型的使用
  - Kafka 客户端底层使用了 Java 的 selector，而 selector 在 Linux 上的实现机制是 epoll，而在 Windows 上的实现机制是 select。epoll 相比于 select 会有更高效的 I/O 性能。[IO](../../../Common/IO.md)
- 数据网络传输效率
  - Kafka 生产和消费的消息都是通过网络传输的，而消息保存在磁盘上，所以 Kafka 需要在磁盘和网络间进行大量数据传输。Linux 实现了零拷贝机制，而 Window 上必须要等到 Java 8 的 60 更新版本才能支持。
- 社区支持度
  - 社区目前对 Windows 平台上发现的 Kafka Bug 不做任何承诺。

## Kafka 的磁盘资源规划

 > 尽管 Kafka 大量使用磁盘，但它的使用方式多是顺序读写操作，一定程度上规避了机械磁盘随机读写慢的劣势，而机械磁盘因易损坏而造成的可靠性差等缺陷，又由 Kafka 在软件层面提供机制保证，所以使用普通机械磁盘更划算。

Kafka 需要将消息保存在底层的磁盘上，这些消息默认会被保存一段时间然后自动被删除。规划磁盘容量时需要考虑**新增消息数、消息留存时间、平均消息大小、备份数、是否启用压缩**。

假设每天需要向 Kafka 集群发送 1 亿条消息（每条消息平均 1KB），每条消息保存两份以防数据丢失，且消息默认保存两周时间。

1 亿条消息：$1亿*1KB*2/1000/1000=200GB$

Kafka 集群除了消息数据还有其他类型的数据，如索引数据，为这些数据预留 10% 的磁盘空间，所以总的存储容量为 220GB，保存两周，则整体容量即为 220 * 14 大约 3TB。而 Kafka 支持数据的压缩，假设压缩比为 0.75，需要规划的存储空间就是 $0.75*3=2.25TB$。

## Kafka 的带宽资源规划

假设使用 1Gbps 的千兆网络，现在有个业务，其业务目标或 SLA 是在 1h 内处理 1TB 的业务数据，那么需要多少台 Kafka 服务器来完成业务？

带宽为 1Gbps，即每秒处理 1Gb 数据，假设每台 Kafka 服务器都安装在专属机器上（每台机器没有混布其他服务），通常情况下假设 Kafka 会用到 70% 的带宽资源，因为总要为其他应用或进程预留一些资源。

> 根据实际使用经验，超过 70% 的阈值就有网络丢包的可能性了，故 70% 的设定是一个比较合理的值，也就是说单台 Kafka 服务器最多也就能使用大约 700Mb 的带宽资源

而 70% 的阈值又是能使用的最大带宽资源，不能让 Kafka 服务器常规性使用这么多资源，故通常还要再额外预留出 2/3 的资源，即单台服务器使用带宽为 700Mb/3=240Mbps。

1h 处理 1TB 的数据，每秒需要处理 $1024*1024/3600*8=2336Mb$ 的数据，除以 10，约等于 10台服务器，如果消息还需要额外复制两份，那么总的服务器台数还要乘以 3，即 30 台。

注：带宽资源一般用 Mbps 而不是 MBps 衡量！！

# Kafka 集群的几个参数

## Broker 端参数

- 针对存储信息的参数
    - `log.dirs`，指定Broker 需要使用的若干个文件目录路径。没有默认值，必须指定
    - `log.dir`，只能表示单个路径，用于补充上一个参数

以上两个参数仅设置第一个即可，生产环境一定要为 log.dirs 配置多个路径，使用逗号分隔。

多个目录最好挂载在不同物理磁盘上，既可以提升读写性能，还能实现故障转移，即 Failover。

> Failover 为 Kafka 1.1 版本引入的功能。以前只要 Broker 使用的任何一块磁盘挂了，整个 Broker 进程都会关闭。而 1.1 以后，坏掉的磁盘上的数据会自动转移到其他正常的磁盘，且 Broker 还能正常工作。

- ZooKeeper 相关参数
  - `zookeeper.connect` 指定多个 ZooKeeper 的连接信息，使用逗号分隔，如 `zk1:2181,zk2:2181,zk3:2181`

让多个 Kafka 集群使用同一个 ZooKeeper 集群。假设有两个 Kafka 集群（kafka1、kafka2），则它们的 `zookeeper.connect` 可以设置为：`zk1:2181,zk2:2182,zk3:2181/kafka1` 和 `zk1:2181,zk2:2182,zk3:2181/kafka2`。

- 客户端程序或其他 Broker 如何与该 Broker 通信的参数
  - `listeners`，外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务
  - `advertised.listeners`，这组 listernes 是 Broker 为外网访问用的

以上两个参数的值的格式为 `<协议名称,主机名,端口号>`，主机名最好不要使用 IP 地址。

- Topic 管理相关参数
  - `auto.create.topics.enable`，是否允许自动创建 Topic，建议设置为 false，避免拼写错误导致奇怪的 Topic 创建
  - `unclean.leader.election.enable`，是否允许 Unclean.Leader 选举
    - 每个分区有多个副本来提供高可用，其中只有一个 Leader 副本对外提供服务，通常只有保存数据较多的副本才有资格竞选 Leader！
    - 假设那些保存数据较多的副本都挂了怎么办？还要不要进行 Leader 选举呢？
    - 该参数如果为 false，则决不允许那些落后太多的副本竞选 Leader，这样做的话该分区因为没有 Leader就不可用了
    - 该参数如果为 true，那么 Kafka 允许从那些“跑得慢”的副本中选 Leader，这样做的话数据可能就丢失了，因为这些副本保存的数据本就不全
    - 建议显式设置为 false
  - `auto.leader.rebalance.enable`，是否允许定期进行 Leader 选举
    - true 表示允许 Kafka 定期对一些 Topic 分区进行 Leader 重选举。注意，这里是换 Leader！
    - 建议设置为 false，因为换 Leader 的代价很高，原本向 A 发送请求的所有客户端都要切换向 B 发送请求。

- 数据留存相关的参数
  - `log.retention.{hour|minutes|ms}`，控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hour 最低
    - 如 `log.retention.hour=168` 默认保存 7 天的数据
  - `log.retention.bytes`，指定 Broker 为消息保存的总磁盘容量大小
    - 默认 -1，保存多少数据都可以
  - `message.max.bytes`，控制 Broker 能够接收的最大消息大小
    - 默认 1000012，不到 1MB，太小

## Topic 级别参数

如果同时设置了 Topic 级别参数和全局 Broker 参数，Topic 级别参数会覆盖全局 Broker 参数的值。

- 保存消息相关参数
  - `retention.ms`，该 Topic 消息被保存的时长，默认 7 天
  - `retention.bytes`，要为该 Topic 预留多大的磁盘空间，默认 -1
  - `max.message.bytes` 决定了 Kafka Broker 能正常接收该 Topic 的最大消息大小



