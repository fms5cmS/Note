缓存作为提升性能的利器无处不在，小到 CPU 缓存架构，大道分布式应用存储。分布式缓存系统提供了热点数据的随机访问机制，大大了提升了访问时间，但是带来的**问题是如何保证数据的一致性，引入分布式锁来解决这个问题**，主流的分布式存储系统基本就是 Redis。

如定时关闭订单，如果是单机的话，只有一个 Tomcat 执行关闭订单的任务，不会出现问题。但是当 Tomcat 集群时，相同的任务会有多个服务同时执行，这样，浪费了 MySQL 和服务器的性能(因为只有一台机器执行就可以了)，同时也会造成数据错乱(大家都在执行 SQL 语句)。

- 分布式锁，是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。
  - 宏观上有两种场景需要用到分布式锁：
    - 效率：锁可以避免不必要地执行相同地工作两次
      如果锁定失败且多个节点最终完成相同的工作，结果是成本略有增加(浪费内存/CPU)或出现重复数据(如给用户发多次短信) 
    - 正确性：锁可以防止并发进程弄乱系统状态
      如果锁定失败且多个节点同时处理同一条数据，则结果是文件损坏、数据丢失，永久性不一致或其他严重问题
  - 分布式锁要满足：
    - 互斥性：在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取；
    - 避免死锁：这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）；
    - 锁删除：当客户端需要释放资源时，会删除 key
    - 高可用：获取或释放锁的机制必须高可用且性能佳。
  - 实现方式：
    - 基于数据库实现，利用主键唯一规则、MySQL 行锁
    - 基于 Redis 实现，主要是依赖 Redis 自身的原子操作
      - Redis 锁的 Java 开源实现：Redission
    - 基于 ZooKeeper 实现：使用它的临时有序节点来实现
    - 方案比较：
      - 实现复杂性：Zookeeper >= 缓存 > 数据库
      - 性能：缓存 > Zookeeper >= 数据库
      - 可靠性：Zookeeper > 缓存 > 数据库

Redis 分布式锁见 [DistributedLock](https://github.com/fms5cmS/arts/blob/master/share/01_distributedLock.md)
