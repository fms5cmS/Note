Test Driven Development(TDD，测试驱动开发)

Go 的三类测试：功能测试（test）、基准测试（benchmark，也叫性能测试）、示例测试（example）。Go 有一个轻量级的测试框架，由 `go test` 命令和 testing 包构成。

- 测试源码文件名必须以 `_test.go` 结尾；
- 测试源码文件内的函数命名方式：
  - 功能测试函数的函数签名必须为 `func TestXxx(t *testing.T)`
    - 测试框架会运行每一个函数。如果函数调用了错误函数如：`t.Error`或`t.Fail`，该测试也会失败。
  - 性能测试函数的函数签名必须为 `func BenchmarkXxx(b *testing.B)`
  - 示例测试函数的函数签名必须为 `func ExampleXxx()`，参数列表不强制

只需要测试包中可被观测到的行为(behaviour，做了什么)，即首字母大写的函数，而不用测试具体的实现；

代码覆盖率则作为指导，如果存在无法通过公共 API 被覆盖的代码，删除它；当重构代码时，使用覆盖率来告诉自己需要添加测试了。



# 基础知识

- 测试流程

`go test` 命令在运行时，会先做一些准备工作，如：确定内部需要用的命令、检查指定的代码包或源码文件的有效性、判断我们给予的标记是否合法等；

准备工作完成后，`go test` 命令会针对每个被测代码包**依次**进行构建，执行包中符合要求的测试函数，清理临时文件，打印测试结果。

注意：`go test` 命令会串行执行测试流程中的每个步骤，但是为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，最后打印测试结果时，会依照我们给定的顺序逐个进行。

另一方面，由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行执行的，具体说就是，只有在所有构建步骤都做完之后，`go test` 命令才会真正开始进行性能测试。且下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才开始，性能测试函数的执行也都会是串行的。

---

- 缓存

go 命令通常会缓存程序构建的结果，以便在将来的构建中重用。GOCACHE 环境变量可以设置缓存目录的路径，使用 `go env GOCACHE` 了查看。缓存的数据总能正确反映出当时的各种源码问价、构建环境、编译器选项等真实情况。

一旦有任何变动，缓存就会失效，go 命令会再次真正地执行操作。go 命令会定期删除最近未使用地缓存数据，也可使用 `go clean -cache` 手动删除所有缓存数据。

对于测试成功地结果，go 命令也会缓存。`go clean -testcache` 命令可以删除所有地测试结果缓存，不过不会删除构建结果缓存。

对于失败测试地结果，`go test` 命令不会进行缓存。

---

- 命令参数

性能测试相关的命令参数见性能测试部分。

- `-run=`表明要执行包中的哪些功能测试函数
- `-v`，`go test` 只会打印测试结果，而不会打印常规的测试日志，如果想要在在测试结果中看到所有的常规测试日志（如，哪一行失败、成功、输出结果），需要使用 `-v`
- `-cpu=n` 指定测试执行最大 P 数量
- `-coverprofile=c.out` 可以在测试的同时获取代码覆盖报告并输出到 c.out 文件中
  -  `go tool cover -func=c.out` 列出每个函数的代码覆盖率
  - `go tool cover -html=c.out` 在网页查看代码覆盖信息

---

- 测试中用于失败的方法

如果想让某个测试函数在执行过程中立即失败，可以在测试函数中调用 `t.FailNow()` 方法，调用语句之后的代码都会失去执行机会。

如果调用地是 `t.Fail()` 方法，虽然测试函数最终会失败，不过在调用语句后面的代码还是会执行。

如果想在测试失败的同时打印失败测试日志，可以直接调用 `t.Error()` 或 `t.Errorf()` 方法，前者相当于 `t.Log()` 和 `t.Fail()` 的连续调用，后者相当于调用了 `t.Logf()` 和 `t.Fail()`。

此外，`t.Fatal()` 和 `t.Fatalf()` 是在打印失败错误日志后立即终止当前测试函数的执行。相当于它们在最后都调用了 `t.FailNow()`。



# 功能测试

## 表格驱动测试

要测试的函数：

```go
func Split(s, sep string) []string {
	var result []string
	i := strings.Index(s, sep)
	for i > -1 {
		result = append(result, s[:i])
		s = s[i+len(sep):]
		i = strings.Index(s, sep)
	}
	return append(result, s)
}
```

对上面这个函数进行代码测试：

```go
// 测试正常的数据
func TestSplit(t *testing.T) {
	got := Split("a/b/c", "/")
	want := []string{"a", "b", "c"}
	if !reflect.DeepEqual(want, got) {
		t.Fatalf("expected: %v, got: %v", want, got)
	}
}
// 测试分隔符与字符串中不符的情况
func TestSplitWrongSep(t *testing.T) {
	got := Split("a/b/c", ".")
	want := []string{"a/b/c"}
	if !reflect.DeepEqual(want, got) {
		t.Fatalf("expected: %v, got: %v", want, got)
	}
}
// 测试分隔符不存在时的情况
func TestSplitNoSep(t *testing.T) {
	got := Split("abc", "/")
	want := []string{"abc"}
	if !reflect.DeepEqual(want, got) {
		t.Fatalf("expected: %v, got: %v", want, got)
	}
}
```

对同一个函数不同测试数据(test cases)的测试代码中存在很多重复的内容，将上面三个 cases 的不同之处抽取出来作为一个结构体：

```go
func TestSplit(t *testing.T) {
  type test struct {
    input string
    sep   string
    want  []string
  }
  tests := []test{
    {input: "a/b/c", sep: "/", want: []string{"a", "b", "c"}},
    {input: "a/b/c", sep: ".", want: []string{"a/b/c"}},
    {input: "abc", sep: "/", want: []string{"abc"}},
  }
  for _, tc := range tests {
    got := Split(tc.input, tc.sep)
    if !reflect.DeepEqual(tc.want, got) {
      // 注意，这里使用的是 Errorf 函数，如果继续使用 Fatalf，当某一个测试数据报错，就会终止测试代码，后面的 测试数据就无法被测试了
      t.Errorf("expected: %v, got: %v", tc.want, got)
    }
  }
}
```

这就是**表格驱动测试**，测试数据和测试逻辑分离；明确的出错信息；可以部分失败！

上面的测试代码对于报错信息不够明确，对上述代码的测试数据进行修改并简化后：

```go
func TestSplit(t *testing.T) {
  tests := []struct {
    name string  // 用于明确报错时是哪个数据报错
    input string
    sep   string
    want  []string
  }{
    {name:"simple",input: "a/b/c", sep: "/", want: []string{"a", "b", "c"}},
    {name:"wrong sep",input: "a/b/c", sep: ".", want: []string{"a/b/c"}},
    {name:"no sep",input: "abc", sep: "/", want: []string{"abc"}},
    {name:"trailing sep",input: "a/b/c/", sep: "/", want: []string{"a", "b", "c"}},
  }
  for _, tc := range tests {
    got := Split(tc.input, tc.sep)
    if !reflect.DeepEqual(tc.want, got) {
      t.Errorf("%s: expected: %v, got: %v", tc.name, tc.want, got)
    }
  }
}
```

如果使用 map 结构来存储测试数据：

```go
func TestSplit(t *testing.T) {
  tests := map[string]struct {
    input string
    sep   string
    want  []string
  }{
    "simple":    {input: "a/b/c", sep: "/", want: []string{"a", "b", "c"}},
    "wrong sep": {input: "a/b/c", sep: ".", want: []string{"a/b/c"}},
    "no sep":    {input: "abc", sep: "/", want: []string{"abc"}},
    "trailing sep":{input: "a/b/c/", sep: "/", want: []string{"a", "b", "c"}},
  }
  for name,tc := range tests{
    t.Log(name)
    got := Split(tc.input, tc.sep)
    if !reflect.DeepEqual(tc.want, got) {
      t.Errorf("%s: expected: %v, got: %v", name, tc.want, got)
    }
  }
}
```

使用 map 结构存储测试数据也就意味着在运行时，数据的测试是无序的，所以建议**使用 map 存储测试数据**！



## 子测试

子测试是自 Go1.7 开始支持的，使用示例如下：

```go
func TestSplit(t *testing.T) {
  tests := map[string]struct {
    input string
    sep   string
    want  []string
  }{
    "simple":    {input: "a/b/c", sep: "/", want: []string{"a", "b", "c"}},
    "wrong sep": {input: "a/b/c", sep: ".", want: []string{"a/b/c"}},
    "no sep":    {input: "abc", sep: "/", want: []string{"abc"}},
    "trailing sep":{input: "a/b/c/", sep: "/", want: []string{"a", "b", "c"}},
  }
  for name, tc := range tests {
    // 使用 t.Run() 进行子测试
    t.Run(name, func(t *testing.T) {
      got := Split(tc.input,tc.sep)
      if !reflect.DeepEqual(tc.want, got) {
        // 为了方便看出错误，这里以完整的 Go 语法来打印输出信息
        // 这里使用 Fatalf 函数也可以将所有的测试数据都测试了
        t.Fatalf("expected: %#v, got: %#v", tc.want, got)
      }
    })
  }
}
```

上面示例中共有四个子测试，其name 分别为：simple、wrong_sep、no_sep、trailing_sep ，

使用`go test -run=TestSplit/trailing` 表示只执行 `TestSplit`测试函数中 trailing 相关的子测试。



## 测试中的比较

在测试中经常需要对实际获得和期望得到的结果进行比较，可以使用 [go-cmp](https://github.com/google/go-cmp) 框架进行测试中数据的比较，使用文档见 [GoDoc](https://godoc.org/github.com/google/go-cmp/cmp)。

```go
func TestSplit(t *testing.T) {
  tests := map[string]struct {
    input string
    sep   string
    want  []string
  }{
    "simple":    {input: "a/b/c", sep: "/", want: []string{"a", "b", "c"}},
    "wrong sep": {input: "a/b/c", sep: ".", want: []string{"a/b/c"}},
    "no sep":    {input: "abc", sep: "/", want: []string{"abc"}},
    "trailing sep":{input: "a/b/c/", sep: "/", want: []string{"a", "b", "c"}},
  }
  for name, tc := range tests {
    t.Run(name, func(t *testing.T) {
      got := Split(tc.input,tc.sep)
      diff := cmp.Diff(tc.want, got)
      if diff!= "" {
        t.Fatalf(diff)
      }
    })
  }
}
```

测试发现代码是存在问题的，对代码进行改进：

```go
func SplitBetter(s, sep string) []string {
  var result []string
  i := strings.Index(s, sep)
  for i > -1 {
    result = append(result, s[:i])
    s = s[i+len(sep):]
    i = strings.Index(s, sep)
  }
  if len(s)> 0 {
    result = append(result, s)
  }
  return result
}
```





# 性能测试

命令行方式：`go test -bench=. -run=^$ 包路径`，
- `-bench`有了这个标记，命令才会进行性能测试，该标记的值 `.` 表示需要执行任意名称的性能测试函数，是一个正则表达式
- `^$`表示只执行名称为空的功能测试函数，即不执行任何功能测试函数，也是正则表达式
- 使用`-cpuprofile cpu.out`将性能信息输出到一个 cpu.out 文件中，使用`go tool pprof cpu.out`可以查看，会进入一个命令行交互的模式，查看过程中可以使用很多命令来操作：如：
  - `help`查看可以做的操作；
  - `web`可以在网页查看！（需要安装 Graphviz，在[官网](https://graphviz.gitlab.io/_pages/Download/Download_windows.html)下载，安装或解压后配置到环境变量Path中）
  - `quit`退出

```go
func BenchmarkTriangle(b *testing.B) {
  m, n, j := 12, 35, 37
  b.ResetTimer()   //只关心下面代码的性能耗时，而不需要准备数据的时间
  for i := 0; i < b.N; i++ {
    actual := calcTriangle(m, n)
    if actual != j {
      b.Errorf("calcTriangle(%d , %d);"+"got %d; expected %d", m, n, actual, j)
    }
  }
}
```

输入 `go test -bench=. ` 命令后输出结果：

```go
goos: windows
goarch: amd64
pkg: zzk.com/fms5cms/geekbang/base/benchtest
//表示命令执行了性能测试函数，且当时所用最大 P 数量为 8
//最大 P 数量相当于可同时运行 goroutine 的逻辑 CPU 的最大个数。这里的逻辑 CPU 也可被称为 CPU 核心，但并不等同于真正的 CPU 核心，只是 Go 运行时系统内的一个概念，代表同时运行 goroutine 的能力。可通过 runtime.GOMAXPROCS 函数改变最大 P 数
//2000000000 是被测函数被执行的实际次数，不是性能测试函数的执行次数！
//0.67 ns/op表明单次执行被测函数的平均耗时为 0.67ns
BenchmarkTriangle-8     2000000000       0.67 ns/op
PASS
ok    zzk.com/fms5cms/geekbang/base/benchtest 1.705s  //总耗时 1.705s
```

`go test` 在执行性能测试函数时，会给它一个正整数，若该测试函数的唯一参数名为 b，则该正整数由 `b.N` 代表，在测试函数中应配合着编写代码，见上面的示例。


