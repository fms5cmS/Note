# Logger、Recovery

`gin.Default()` 默认使用了 Logger、Recovery 这两个中间件，其中 Logger 中间件默认是向控制台输出的，如果想将日志打印到文件：

```go
func main() {
   // 创建日志文件
   logFile, _ := os.Create("gin.log")
   // 设置默认的 Writer，这里将错误也写入到了日志文件中
   gin.DefaultWriter = io.MultiWriter(logFile)
   gin.DefaultErrorWriter = io.MultiWriter(logFile)

   r := gin.New()
   // 添加日志中间件
   r.Use(gin.Logger())
   r.GET("/logger", func(c *gin.Context) {
      name := c.DefaultQuery("name", "default_name")
      c.String(200, "%s", name)
   })
   r.Run()
}
```

Recovery 确保单个请求发生 panic 时记录异常堆栈日志，输出统一的错误响应。不使用 Recovery 的话，如果程序出现 panic，程序会挂掉，再进行请求是不会获得响应的，使用后，程序不会挂掉。

# 自定义中间件

gin 允许在处理请求时，加入用户自己的钩子函数，该钩子函数即中间件。其作用与 Java 中的拦截器相似。

中间件需要返回`gin.HandlerFunc`函数，多个中间件通过 `Next()` 函数来依次执行。

```go
// 自定义一个 IP 白名单中间件
func IPAuthMiddleware() gin.HandlerFunc {
  return func(c *gin.Context) {
    ipList := []string{"127.0.0.2"}  // IP 白名单
    flag := false
    clientIP := c.ClientIP() // 获取客户端 IP
    for _, host := range ipList {
      if clientIP == host {
        flag = true
        break
      }
    }
    if !flag{
      c.String(401,"%s not in iplist", clientIP)
      c.Abort()
    }
    c.Next()
  }
}

func main() {
  r := gin.Default()
  r.Use(IPAuthMiddleware()) // 在整个项目中使用该中间件。
  // 也可以只在某个路由函数中使用中间件，如：
  // r.GET("/user/login", IPAuthMiddleware(),  userLogin)
  r.GET("/test", func(c *gin.Context) {
    c.String(200, "hello test")
  })
  r.Run()
}
```
