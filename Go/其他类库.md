# unsafe

包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中。

`unsafe.Pointer` 类型也代表指针，可以表示任何指向可寻址（addressable）的值的指针。通过它，可以在指针值和 `uintptr` 这两种值之间进行转换。

## 不可寻址的值

Go 语言中不可寻址的值有：不可变、临时结果、不安全

- 常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是**不可变的**。
- 基本类型值的字面量也是一样，其实它们本就可以被视为常量，只不过没有任何标识符可以代表它们

```go
const num = 123
// _ = &num // 常量不可寻址，编译报错
// _ = &(123) // 基本类型值的字面量不可寻址，编译报错
```

- Go 语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的，因为即使拿到了这种值的内存地址也改变不了什么
- 函数也是不可变的，且拿到指向一段代码的指针是**不安全**的
  - “不安全的” 操作很可能会破坏程序的一致性，引发不可预知的错误，从而严重影响程序的功能和稳定性

```go
var str = "abc"
_ = str
// _ = &(str[0])   // 对字符串变量的索引结果值不可寻址。
// _ = &(str[0:2]) // 对字符串变量的切片结果值不可寻址。
str2 := str[0]
_ = &str2 // 但这样的寻址就是合法的。
//_ = &(func(x, y int) int {
//	return x + y
//}) // 字面量代表的函数不可寻址。
//_ = &(fmt.Sprintf) // 标识符代表的函数不可寻址。
//_ = &(fmt.Sprintln("abc")) // 对函数的调用结果值不可寻址。
```

- 算术操作的结果值属于一种**临时结果**。在我们把这种结果值赋给任何变量或常量之前，即使能拿到它的内存地址也是没有任何意义的。
- 如果把临时结果赋给一个变量，那么它就是可寻址的了

```go
// _ = &(123 + 456) // 算术操作的结果值不可寻址。
num2 := 456
_ = num2
// _ = &(num + num2) // 算术操作的结果值不可寻址。
a := 123 + 456
b := &a
```

- 数组值、切片值或字典值的**字面量**的表达式会产生临时结果，所以是不可寻址的
  - 对切片字面量的索引结果值是可寻址的。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。

```go
//_ = &([3]int{1, 2, 3}[0]) // 对数组字面量的索引结果值不可寻址。
//_ = &([3]int{1, 2, 3}[0:2]) // 对数组字面量的切片结果值不可寻址。
_ = &([]int{1, 2, 3}[0]) // 对切片字面量的索引结果值却是可寻址的。
//_ = &([]int{1, 2, 3}[0:2]) // 对切片字面量的切片结果值不可寻址。
//_ = &(map[int]string{1: "a"}[0]) // 对字典字面量的索引结果值不可寻址。
```

- 上面说是对数组值、切片值或字典值的**字面量**的表达式会产生临时结果，但是，如果针对的是数组类型或切片类型的变量，那么索引或切片的结果值就都不属于临时结果了，是可寻址的
  - 对字典类型的变量施加索引表达式，得到的结果值不属于临时结果！
    - 字典中的每个键 - 元素对的存储位置都可能会变化，且这种变化外界是无法感知的

```go
a := [3]int{1, 2, 3}
b := &a[0]   // 对数组变量的索引表达式是可寻址的
var map1 = map[int]string{1: "a", 2: "b", 3: "c"}
_ = map1
//_ = &(map1[2]) // 对字典变量的索引结果值不可寻址。
```

## 重要

在函数部分的笔记中说过：在基本类型的变量上调用该类型的指针方法，编译器会自动进行重写，如：

```go
type dog struct {
	name string
}

func (dog *dog) setName(name string) {
	dog.name = name
}

func new(name string) dog {
	return dog{name}
}

func main() {
	m := dog{"wang"}
	m.setName("mie")  // 编译器自动重写为 &m.setName("mie")
	new("black").setName("white")  // 编译时会报错
  // new() 的结果属于临时结果，是不可寻址的，所以无法进行取址操作！！！
}
```

Go 语言中的 `++` 和 `--` 不是操作符，只要在 `++` 或 `--` 的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是，**这个表达式的结果值必须是可寻址的**。

有一个例外，虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。

还有两个类似的规则：

在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。

在带有`range`子句的`for`语句中，在`range`关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。

# io

![](../images/Go-io.png)

在 io 包中，`io.Reader` 的扩展接口和实现类型都有哪些？它们分别都有什么功用？

- `io.ReadWriter`：既是`io.Reader`的扩展接口，也是`io.Writer`的扩展接口。该接口定义了一组行为，包含且仅包含了基本的字节序列读取方法`Read`，和字节序列写入方法`Write`。
- `io.ReadCloser`：除了包含基本的字节序列读取方法之外，还拥有一个基本的关闭方法`Close`。后者一般用于关闭数据读写的通路。这个接口其实是`io.Reader`接口和`io.Closer`接口的组合。
- `io.ReadWriteCloser`：`io.Reader`、`io.Writer`和`io.Closer`这三个接口的组合。
- `io.ReadSeeker`：有一个用于寻找读写位置的基本方法`Seek`，该方法可以根据给定的偏移量基于数据的起始位置、末尾位置，或者当前读写位置去寻找新的读写位置。这个新的读写位置用于表明下一次读或写时的起始索引。`Seek`是`io.Seeker`接口唯一拥有的方法。
- `io.ReadWriteSeeker`：`io.Reader`、`io.Writer`和`io.Seeker`的组合。

`io`包中的`io.Reader`接口的实现类型：

- `*io.LimitedReader`：此类型的基本类型会包装`io.Reader`类型的值，并提供一个额外的受限读取的功能。所谓的受限读取指的是，此类型的读取方法`Read`返回的总数据量会受到限制，无论该方法被调用多少次。这个限制由该类型的字段`N`指明，单位是字节。
- `*io.SectionReader`：此类型的基本类型可以包装`io.ReaderAt`类型的值，并且会限制它的`Read`方法，只能够读取原始数据中的某一个部分（或者说某一段）。
  这个数据段的起始位置和末尾位置，需要在它被初始化的时候就指明，并且之后无法变更。该类型值的行为与切片有些类似，它只会对外暴露在其窗口之中的那些数据。
- `*io.teeReader`：此类型是一个包级私有的数据类型，也是`io.TeeReader`函数结果值的实际类型。这个函数接受两个参数`r`和`w`，类型分别是`io.Reader`和`io.Writer`。
  其结果值的`Read`方法会把`r`中的数据经过作为方法参数的字节切片`p`写入到`w`。可以说，这个值就是`r`和`w`之间的数据桥梁，而那个参数`p`就是这座桥上的数据搬运者。
- `io.multiReader`：此类型也是一个包级私有的数据类型。类似的，`io`包中有一个名为`MultiReader`的函数，它可以接受若干个`io.Reader`类型的参数值，并返回一个实际类型为`io.multiReader`的结果值。
  当这个结果值的`Read`方法被调用时，它会顺序地从前面那些`io.Reader`类型的参数值中读取数据。因此，我们也可以称之为多对象读取器。
- `io.pipe`：此类型为一个包级私有的数据类型，它比上述类型都要复杂得多。它不但实现了`io.Reader`接口，而且还实现了`io.Writer`接口。
  实际上，`io.PipeReader`类型和`io.PipeWriter`类型拥有的所有指针方法都是以它为基础的。这些方法都只是代理了`io.pipe`类型值所拥有的某一个方法而已。
  又因为`io.Pipe`函数会返回这两个类型的指针值并分别把它们作为其生成的同步内存管道的两端，所以可以说，`*io.pipe`类型就是`io`包提供的同步内存管道的核心实现。
- `io.PipeReader`：此类型可以被视为`io.pipe`类型的代理类型。它代理了后者的一部分功能，并基于后者实现了`io.ReadCloser`接口。同时，它还定义了同步内存管道的读取端。

## 文件拷贝

- `io.Copy(dst Writer, src Reader) (written int64, err error)`

```go
func copy(src, dst string) error {
  // 获取 src 的信息
  srcInfo, _ := os.Stat(src)
  // 判断 src 是否是一个文件
  if !srcInfo.Mode().IsRegular() {
    return fmt.Errorf("%s is not a regular file", src)
  }
  source, _ := os.Open(src)
  defer source.Close()
  destination, _ := os.Create(dst)
  defer destination.Close()
  _, err := io.Copy(destination, source)
  return err
}
```

---

- `ReadFile(filename string) ([]byte, error)`
- `WriteFile(filename string, data []byte, perm os.FileMode) error`

```go
	data, _ := ioutil.ReadFile(src)
	err := ioutil.WriteFile(dst, data, os.ModePerm)
	if err != nil {
		fmt.Println("Creating file error", err)
	}
```

---

- `Read(b []byte) (n int, err error)`
- `Write(b []byte) (n int, err error)`

```go
func TestCopy(t *testing.T) {
	src, _ := os.Open("latex.pdf")
	dst, _ := os.Create("dst.pdf")
	defer src.Close()
	defer dst.Close()
	buf := make([]byte, 2*1024)
	for {
		_, err := src.Read(buf)
		if err == io.EOF{
			break
		}
		dst.Write(buf)
	}
}
```

# bytes

**面对的主要是字节和字节切片。**

## Buffer

实现了`io.Reader`、`io.ByteReader`、`io.RuneReader`、`io.ByteScanner`、`io.RuneScanner`、`io.WriterTo`、`io.Writer`、`io.ByteWriter`、`io.stringWriter`、`io.ReaderFrom` 、`fmt.Stringer`接口。

`bytes.Buffer` 主要用作字节序列的缓冲区。可以拼接、截断其中的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。

```go
type Buffer struct {
	buf      []byte // contents are the bytes buf[off : len(buf)]
	off      int    // 代表已读字节的计数
	lastRead readOp // last read operation, so that Unread* can work correctly.
}
```

```go
func TestBuffer(t *testing.T) {
	var byteBuf bytes.Buffer
	readBuf := make([]byte,2)
	byteBuf.WriteString("my favorite animation is clannad")
	t.Logf("未读的长度：%d\n", byteBuf.Len())
	t.Logf("容量：%d\n", byteBuf.Cap())
	byteBuf.Read(readBuf)
	t.Logf("读取 2 个字节后，未读的长度：%d\n", byteBuf.Len())
}
```

`bytes.Buffer` 并没有 `strings.Reader` 的 `Size()` 方法可以得到内容长度，所以复杂情况时很难估算出 `Buffer` 的已读计数。

**用于读回退的方法有 `UnreadByte` 和 `UnreadRune`。** 这两个方法分别用于回退一个字节和回退一个 Unicode 字符。调用它们一般都是为了退回在上一次被读取内容末尾的那个分隔符，或者为重新读取前一个字节或字符做准备。

退回的前提是，在调用它们之前的那一个操作必须是 “读取”，并且是成功的读取，否则这些方法就只能忽略后续操作并返回一个非`nil`的错误值。

`bytes.Buffer` 的已读计数 `off` 有什么用？

1. 读取内容时，相应方法会依据已读计数找到未读部分，并在读取后更新计数。
2. 写入内容时，如需扩容，相应方法会根据已读计数实现扩容策略。
3. 截断内容时，相应方法截掉的是已读计数代表索引之后的未读部分。
4. 读回退时，相应方法需要用已读计数记录回退点。
5. 重置内容时，相应方法会把已读计数置为 `0`。
6. 导出内容时，相应方法只会导出已读计数代表的索引之后的未读部分。
7. 获取长度时，相应方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回

`bytes.Buffer` 的扩容策略：先判断底层字节切片的剩余容量是否足够容纳新的内容，如果可以，会在当前的字节切片上进行长度扩充；否则，可能会用新的字节切片（仅向其中拷贝了原来未读的内容）替代原有的字节切片，off 重置为 0，从而实现扩容。

注意：如果当前字节切片的容量的一半 >= 现有字节切片长度 + 需要的字节数，则会复用现有的字节切片，并把切片中未读部分的内容拷贝到头部位置，同时 off 重置为 0。

如果用新的字节切片替代原有的切片，新容量 = 2 \* 原容量 + 所需字节数。

对于零值的 `bytes.Buffer` 而言，如果第一次扩容时所需的字节数 <= 64，则会基于一个预先定义好的、长度为 64 的字节数组来创建 `bytes.Buffer` 的底层切片。
